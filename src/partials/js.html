<section class="course-section">
  <nav class="left-aside">
    <details>
      <summary class="nav-item">Основи JavaScript</summary>
      <a class="nav-link" href="#js">Мова JavaScript</a>
      <a class="nav-link" href="#value">Змінні та типи даних</a>
      <a class="nav-link" href="#message">Рядки</a>
      <a class="nav-link" href="#operators">Оператори порівняння</a>
      <a class="nav-link" href="#functions">Основи функцій</a>
    </details>
    <details>
      <summary class="nav-item">Розгалуження і цикли</summary>
      <a class="nav-link" href="#branching">Розгалуження</a>
      <a class="nav-link" href="#logical-operators">Логічні оператори</a>
      <a class="nav-link" href="#string-methods">Методи рядків</a>
      <a class="nav-link" href="#loops">Цикли</a>
      <ul>
        <li>
          <a href="#while">Цикл <code>while</code></a>
        </li>
        <li>
          <a href="#do...while">Цикл <code>do...while</code></a>
        </li>
        <li>
          <a href="#for">Цикл <code>for</code></a>
        </li>
        <li>
          <a href="#increment-decrement">Інкремент і декремент</a>
        </li>
        <li>
          <a href="#break">Оператор <code>break</code></a>
        </li>
      </ul>
    </details>
    <details open>
      <summary class="nav-item">Масиви і функції</summary>
      <a class="nav-link" href="#arrays">Масиви</a>
      <a class="nav-link" href="#array-methods">Методи масивів</a>
      <ul>
        <li>
          <a href="#join()">Метод <code>join()</code></a>
        </li>
        <li>
          <a href="#split()">Метод <code>split()</code></a>
        </li>
        <li>
          <a href="#slice()">Метод <code>slice()</code></a>
        </li>
        <li>
          <a href="#concat()">Метод <code>concat()</code></a>
        </li>
        <li>
          <a href="#indexOf()">Метод <code>indexOf()</code></a>
        </li>
        <li>
          <a href="#push()">Метод <code>push()</code></a>
        </li>
      </ul>
    </details>
  </nav>
  <div class="course-container">
    <!--1. Модуль 1. Змінні та типи. Основи функцій-->
    <!--Мова JavaScript-->
    <section>
      <h1 id="js" class="hero-title">Мова JavaScript</h1>
      <p>
        <strong>JavaScript</strong> — високорівнева мова програмування, що
        підтримується всіма сучасними веббраузерами.
      </p>
      <p>
        У Front-end розробці JavaScript використовується у зв'язці з HTML та CSS
        для забезпечення функціональності вебсторінки, такої як:
      </p>
      <ul class="ul">
        <li>нескладні обчислення;</li>
        <li>перевірка та маніпуляція даними, які було введено користувачем;</li>
        <li>зберігання інформації у браузері користувача;</li>
        <li>динамічна зміна HTML-документа;</li>
        <li>реакція на дії користувача;</li>
        <li>створення інтерактивних елементів: галерей, графіків тощо;</li>
        <li>взаємодія з бекендом.</li>
      </ul>
      <pre class="ql-blockquote" spellcheck="false">
Якщо JavaScript-код пишеться для виконання в браузері (Front-end), розробник не має інструментів і доступу до файлової або операційної системи з міркувань безпеки.</pre
      >
      <p>
        Також на сьогоднішній день, використовуючи JavaScript, можна створювати:
      </p>
      <ul class="ul">
        <li>
          вебдодатки на фреймворках <code>React</code>, <code>Vue</code>,
          <code>Angular</code> тощо;
        </li>
        <li>бекенд програми на <code>Node.js</code>;</li>
        <li>мобільні додатки на <code>React Native</code>;</li>
        <li>десктоп програми за допомогою <code>Electron</code>.</li>
      </ul>
      <p>
        <strong>Інструкція</strong> (statement) — це пов'язаний набір слів і
        символів із синтаксису мови, які об'єднуються, щоб висловити одну ідею,
        тобто одну інструкцію для машини.
      </p>
      <ul class="ul">
        <li>
          вебдодатки на фреймворках <code>React</code>, <code>Vue</code>,
          <code>Angular</code> тощо;
        </li>
        <li>бекенд програми на <code>Node.js</code> ;</li>
        <li>мобільні додатки на <code>React Native</code>;</li>
        <li>десктоп програми за допомогою <code>Electron</code>.</li>
      </ul>
      <pre class="ql-blockquote" spellcheck="false" data-highlighted="yes">
a = b * 2;</pre
      >
      <p>У JavaScript інструкції закінчуються <code>;</code>.</p>
      <ul class="ul">
        <li>
          <code>a</code> і <code>b</code> — змінні (як у рівнянні алгебри).
          Змінні — це сховища даних, які використовує програма. Вони складаються
          з ідентифікатора (імені) та пов'язаного з ним значення.
        </li>

        <li>
          <code>2</code> — просто число. Це називається
          <strong>значенням літералу</strong> (literal value), оскільки воно не
          зберігається у змінній.
        </li>
        <li>
          <code>=</code> і <code>*</code> — оператори, що виконують дії над
          значеннями та змінними.
        </li>
      </ul>
      <p><strong>Як працюватиме ця інструкція?</strong></p>
      <p>
        Уявимо, що змінна <code><strong>b</strong></code> зберігає будь-яке
        число, наприклад <code><strong>10</strong></code
        >. Тоді ця інструкція каже машині таке:
      </p>
      <ol class="ol">
        <li>
          Піди знайди змінну з ідентифікатором <code><strong>b</strong></code> і
          дізнайся, яке в неї зараз значення.
        </li>
        <li>
          Підстав значення змінної <code><strong>b</strong></code> (наприклад
          10) в інструкцію замість <code><strong>b</strong></code
          >.
        </li>
        <li>
          Виконай операцію множення <code><strong>10</strong></code> на
          <code><strong>2</strong></code
          >.
        </li>
        <li>
          Запиши результат обчислення виразу з правого боку у змінну
          <code><strong>a</strong></code
          >.
        </li>
      </ol>
      <p>
        Отже, значення змінної <code><strong>a</strong></code> дорівнюватиме
        <code><strong>20</strong></code
        >. Ця інструкція виконується послідовно і є основою виконання дій у
        програмі.
      </p>
      <strong class="ql-size-large">Вираз та літерал</strong>
      <p>
        У людських мовах є речення, що виражають закінчену думку. Речення
        складаються із фраз.
      </p>
      <p>
        Аналогічно, у мовах програмування є інструкції, що дають команду
        комп’ютеру. Інструкції складаються з менших частин — виразів.
      </p>
      <p>
        <strong>Вираз</strong> (expression) — це посилання на змінну чи
        значення, або на набір змінних і значень у поєднанні з операторами.
      </p>
      <img
        src="../js/images/5e8aade5-549a-44d2-ad5a-359efb201dd3m01-b01-s04.jpg"
      />
      <p>
        У цьому прикладі інструкція містить 5 виразів. Кожна інструкція виділена
        квадратними дужками для візуалізації (це не синтаксис мови):
      </p>
      <ul class="ul">
        <li>
          <code>2</code> — вираз значення літерала. Тут використовується
          числовий літерал, що представляє число 2
        </li>
        <li>
          <code>b</code> та <code>a</code> — вирази змінних. Вони вказують на
          необхідність використовувати значення змінних <code>b</code> та
          <code>a</code> відповідно. Однак значення цих змінних будуть
          використані лише у випадку, якщо змінні стоять у правій частині виразу
          присвоювання
        </li>
        <li>
          <code>b * 2</code> — арифметичний вираз множення. Тут значення змінної
          <code>b</code> множиться на число <code>2</code>
        </li>
        <li>
          <code>a = b * 2</code> — вираз присвоювання. У даному випадку він
          вказує на необхідність обчислення правої частини виразу й присвоювання
          результату змінній <code>a</code>, що знаходиться в лівій частині
          виразу
        </li>
      </ul>
      <p>
        Існують інші типи виразів: вирази виклику функцій, вирази порівняння
        тощо.
      </p>
      <p>
        <strong>Літерал</strong> — це значення, яке вказується безпосередньо в
        коді програми та представляє певний тип даних.
      </p>
      <ul class="ul">
        <li>Числовий літерал — це число, записане в коді програми.</li>
        <li>
          Рядковий літерал — це послідовність символів, укладених у лапки.
        </li>
      </ul>
      <p>
        Літерали використовуються, щоб задати початкові значення змінних та
        інших операцій, де потрібно конкретне значення.
      </p>

      <pre class="ql-blockquote" spellcheck="false" data-highlighted="yes">
// Числовий літерал
10
        
// Рядковий літерал
"JavaScript is awesome!"</pre
      >

      <strong class="ql-size-large">Підключення скрипта</strong>
      <p>
        Для підключення скрипта JavaScript до HTML-сторінки можна використати
        тег <code>&lt;script&gt;</code>. Існує кілька способів, як це можна
        зробити:
      </p>
      <p><strong>Вбудований скрипт</strong></p>
      <p>
        Можна додати JavaScript-код прямо всередині тега
        <code>&lt;script&gt;</code> всередині тега <code>&lt;head&gt;</code>:
      </p>
      <pre
        class="ql-syntax hljs language-xml"
        spellcheck="false"
        data-highlighted="yes"
      >
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;My HTML-page&lt;/title&gt;
      &lt;script&gt;
        &lt;!--Твій JavaScript-код тут--&gt;
        console.log("Hello, world");
      &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- Вміст сторінки --&gt;
  &lt;/body
&lt;/html&gt;</pre
      >

      <p><strong>Зовнішній скрипт</strong></p>
      <p>
        По-перше, треба створити окремий файл із розширенням <code>.js</code>,
        що містить JavaScript-код. Потім під'єднати цей файл до HTML-сторінки за
        допомогою тега &lt;script&gt;, вказавши шлях до файлу в атрибуті
        <code>src</code>:
      </p>
      <pre class="ql-blockquote" spellcheck="false" data-highlighted="yes">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;My HTML-page&lt;/title&gt;
    &lt;script src="my-script.js" defer&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- Вміст сторінки --&gt;
  &lt;body&gt;
&lt;/html&gt;</pre
      >

      <p>
        Тег <code>&lt;script&gt;</code> з атрибутом <code>defer</code> можна
        вставити як у <code>&lt;head&gt;</code>, так і в
        <code>&lt;body&gt;</code> — немає жодної різниці.
      </p>
      <p>
        У цьому прикладі файл <code>my-script.js</code> містить JavaScript-код,
        який буде виконано на сторінці.
      </p>
      <p>
        Атрибут <code>defer</code> вказує браузеру, що скрипт повинен бути
        виконаний після того, як HTML-документ буде повністю завантажений. Це
        дозволяє уникнути затримки відображення вмісту сторінки.
      </p>

      <p>
        У багатьох випадках краще використовувати зовнішні скрипти, щоб зробити
        код більш читабельним, зручним для підтримки та перевикористання.
      </p>

      <pre class="ql-blockquote" spellcheck="false">
Зверни увагу, що під час написання коду в редакторі VSCode і встановленому в ньому розширенні Live Server, вебсторінка буде перезавантажуватися щоразу, коли зберігаються нові зміни у файлі скрипта.</pre
      >
      <strong class="ql-size-large">Суворий режим</strong>
      <p>
        <strong>Суворий режим</strong> (англ. strict mode) у JavaScript — це
        спеціальний режим виконання коду, який дає змогу переводити скрипт у
        режим повної відповідності сучасному стандарту. Це запобігає певним
        помилкам, наприклад, використанню небезпечних і застарілих конструкцій,
        що робить код надійнішим та дозволяє легше його підтримувати.
      </p>
      <p>
        Щоб увімкнути суворий режим, потрібно додати директиву
        <code>'use strict';</code> на початок скрипта. Наприклад:
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-javascript"
          spellcheck="false"
          data-highlighted="yes"
        >
'use strict';

// Код у суворому режимі</pre
        >
        <button class="copy"></button>
      </div>
      <pre class="ql-blockquote" spellcheck="false">
Рекомендується завжди використовувати суворий режим у своїх проєктах, щоб уникнути непередбачуваних ситуацій і проблем у коді.</pre
      >
      <strong class="ql-size-large">Виведення даних</strong>
      <p>
        Розробнику потрібно перевіряти правильність роботи програми в певний
        момент часу та виводити інформацію в певному місці коду. Для цього є
        консоль в інструментах розробника браузера на вкладці
        <code>Console</code>.
      </p>
      <img
        src="../js/images/0656e9d3-94d1-4cba-aba5-8ad39abb85dbScreenshot 2023-07-04 at 16.51.35.png"
        alt=""
      />
      <p>
        Наступні комбінації клавіш відкривають інструменти розробника на вкладці
        <code>Console</code>:
      </p>
      <ul class="ul">
        <li>
          Windows і Linux
          —&nbsp;<code>Ctrl</code>&nbsp;+&nbsp;<code>Shift</code>&nbsp;+&nbsp;<code>J</code>;
        </li>
        <li>
          MacOS
          —&nbsp;<code>Command</code>&nbsp;+&nbsp;<code>Option</code>&nbsp;+&nbsp;<code
            >J</code
          >
          .
        </li>
      </ul>
      <p>
        <strong>Метод </strong><code><strong>console.log()</strong></code>
      </p>
      <p>
        Щоб вивести дані в консоль розробника використовується метод
        <code>console.log()</code>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value);</pre>
        <button class="copy"></button>
      </div>
      <p>
        Значення <code>value</code>, яке вказано в круглих дужках, буде виведено
        в консоль розробника при виконанні програми.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"JavaScript is awesome!"</span>);
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">10</span>);</pre>
        <button class="copy"></button>
      </div>
      <p>
        При виконанні цього коду в консоль розробника будуть послідовно виведені
        рядок і число.
      </p>
      <img
        src="../js/images/2e0efa32-9ccb-4dcc-80b3-46d0ea254b72Screenshot 2023-07-04 at 16.58.55.png"
        alt=""
      />
    </section>
    <!--Змінні та типи даних-->
    <section>
      <h2 id="value">Змінні та типи даних</h2>

      <strong class="ql-size-large">Оголошення змінних</strong>
      <p>Змінна — це контейнер, який використовується для зберігання даних.</p>
      <p>Змінна складається з:</p>
      <ul class="ul">
        <li>ідентифікатора (унікального імені);</li>
        <li>області пам’яті, де зберігається її значення.</li>
      </ul>
      <img
        src="../js/images/2eeb949e-2023-4cff-8858-0b9d76bb64d8m01-b01-s01.jpg"
        alt=""
      />
      <p>Розглянемо приклади оголошення змінних.</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >const age <span class="hljs-operator">=</span> <span class="hljs-number">20</span><span class="hljs-comment">;</span>
const username <span class="hljs-operator">=</span> <span class="hljs-string">"Mango"</span><span class="hljs-comment">;</span></pre>
        <button class="copy"></button>
      </div>
      <ul class="ul">
        <li>
          Оголошення змінної починається з ключового слова (у прикладі:
          <code>const</code>). У сучасному синтаксисі JavaScript змінні краще
          оголошувати за допомогою ключових слів <code>const</code> і
          <code>let</code>. Створення змінної без ключового слова може призвести
          до помилки.
        </li>
        <li>
          Після ключового слова, через пробіл, вказується ім'я змінної (у
          прикладі:
          <code>age</code> та <code>username</code>).
        </li>
        <li>
          Щоб присвоїти змінній значення, використовують оператор присвоєння
          <code><strong>=</strong></code
          ><strong> </strong>
        </li>
        <li>
          Інструкція оголошення змінної закінчується крапкою з комою
          <code>;</code> .
        </li>
        <li>
          Для кращої читабельності кожне нове оголошення змінної рекомендується
          розпочинати з нового рядка.
        </li>
      </ul>
      <p>
        Після оголошення змінної до неї можна звернутися за допомогою її імені
        далі у коді. Це необхідно для виконання операцій зі значенням змінної.
        Наприклад, для виведення її значення в консоль інструментів розробника.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >const age <span class="hljs-operator">=</span> <span class="hljs-number">20</span><span class="hljs-comment">;</span>
console.log(age)<span class="hljs-comment">; // 20</span>
        
const username <span class="hljs-operator">=</span> <span class="hljs-string">"Mango"</span><span class="hljs-comment">;</span>
console.log(username)<span class="hljs-comment">; // "Mango"</span></pre>
        <button class="copy"></button>
      </div>
      <strong class="ql-size-large">Перевизначення значення</strong>
      <p>
        Для перевизначення значення раніше оголошеної змінної треба після імені
        такої змінної поставити літерал присвоєння
        <code><strong>=</strong></code> і після нього записати нове значення.
        Наприклад:
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >let username <span class="hljs-operator">=</span> <span class="hljs-string">"Mango"</span><span class="hljs-comment">;</span>
<span class="hljs-attribute">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Poly"</span><span class="hljs-comment">;</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Для оголошення
        <strong>змінної, якій згодом можна задати нове значення</strong>,
        використовується ключове слово <code>let</code>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >let username <span class="hljs-operator">=</span> <span class="hljs-string">"Mango"</span><span class="hljs-comment">;</span>
console.log(username)<span class="hljs-comment">; // "Mango"</span>
        
<span class="hljs-attribute">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Poly"</span><span class="hljs-comment">;</span>
console.log(username)<span class="hljs-comment">; // "Poly"</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Якщо змінна оголошена як <code>const</code>,
        <strong>перевизначити її значення неможливо</strong>. При спробі задати
        їй нове значення буде помилка, яку можна побачити в інструментах
        розробника.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        >const username = <span class="hljs-string">"Mango"</span>;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(username); <span class="hljs-comment">// "Mango"</span>
        
<span class="hljs-comment">// ❌ Неправильно, буде помилка</span>
username = <span class="hljs-string">"Poly"</span>; <span class="hljs-comment">// TypeError: Assignment to constant variable.</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Створення змінної без ключового
        слова&nbsp;<code>let</code>&nbsp;або&nbsp;<code>const</code>&nbsp;у
        режимі ”strict mode” призведе до помилки.
      </p>
      <p>
        Змінним, оголошеним через <code>let</code>, необов'язково відразу
        задавати значення. У разі оголошення змінної без значення, змінна
        ініціалізується зі спеціальним значенням
        <code>undefined</code> (<em>англ</em>. не визначено).
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >let username<span class="hljs-comment">;</span>
console.log(username)<span class="hljs-comment">; // undefined</span>
        
<span class="hljs-attribute">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Mango"</span><span class="hljs-comment">;</span>
console.log(username)<span class="hljs-comment">; // "Mango"</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>
        <strong class="ql-size-large">Як вибрати між </strong
        ><code class="ql-size-large"><strong>const</strong></code
        ><strong class="ql-size-large"> і </strong
        ><code class="ql-size-large"><strong>let</strong></code>
      </p>
      <p>
        Основна відмінність між <code>const</code> і <code>let</code> полягає в
        можливості перевизначення значення змінної після її оголошення.
      </p>
      <p>
        Ключове слово <code>const</code> запобігає перевизначенню значення для
        змінної.
      </p>
      <p>
        Ключове слово <code>let</code> дозволяє змінювати значення змінної після
        її оголошення.
      </p>
      <p>
        Більшість змінних не вимагають повторного надання значення. Отже,
        рекомендовано використовувати <code>const</code> за замовчуванням для
        оголошення більшості змінних. Це сприяє створенню коду, який легко
        зрозуміти і підтримувати, адже значення змінних не перевизначаються.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >// Якщо не треба змінювати значення
const username <span class="hljs-operator">=</span> <span class="hljs-string">"Mango"</span><span class="hljs-comment">;</span>
console.log(username)<span class="hljs-comment">;</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>
        Якщо тобі потрібно оновлювати лічильник або зберігати тимчасові значення
        — тобто потрібно змінювати значення змінної під час виконання скрипту,
        <code>let</code> буде кращим вибором.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >// Якщо треба змінювати значення
let username <span class="hljs-operator">=</span> <span class="hljs-string">"Mango"</span><span class="hljs-comment">;</span>
console.log(username)<span class="hljs-comment">;</span>
        
<span class="hljs-attribute">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Poly"</span><span class="hljs-comment">;</span>
console.log(username)<span class="hljs-comment">;</span>
</pre>
        <button class="copy"></button>
      </div>
      <pre class="ql-blockquote" spellcheck="false">
Правило використання const та let може бути таким: — Використовуй const за замовчуванням для оголошення змінних. — Використовуй let, якщо потрібно змінювати значення змінної під час виконання скрипту. Це правило допоможе писати більш надійний, зрозумілий код, який легко підтримувати.</pre
      >

      <strong class="ql-size-large">Найменування</strong>
      <p>
        Є декілька правил, як обрати ім’я для змінної. Ці правила слід
        враховувати, щоб імена були зрозумілими і відповідали загальноприйнятим
        стандартам.
      </p>
      <ol class="ol">
        <li>
          Імена змінних можуть складатися з літер (a-z, A-Z), цифр (0-9),
          символів підкреслення (_) та знака долара ($).
        </li>
        <li>
          Першим символом в імені змінної має бути літера латиниці, символ
          підкреслення або знак долара. Інші символи можуть бути будь-якими з
          допустимих.
        </li>
        <li>
          Імена змінних чутливі до регістру, тобто змінні
          <code><strong>user</strong></code
          >, <code><strong>usEr</strong></code> та
          <code><strong>User</strong></code> вважаються різними змінними.
        </li>
      </ol>
      <p>
        Хороше ім'я змінної має бути зрозумілим та описувати призначення чи
        вміст змінної.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-comment">// ❌ Погано</span>
chislo
korzina_tovariv
profil_koristuvacha
        
<span class="hljs-comment">// ✅ Добре</span>
<span class="hljs-built_in">number</span>
cart
userProfile</pre>
        <button class="copy"></button>
      </div>
      <p>
        Гарною практикою є використання <strong>camelCase нотації</strong> для
        іменування змінних. При camelCase нотації ****перше слово пишеться
        малими літерами, а кожне наступне починається з великої літери,
        наприклад: <code>user</code>, <code>getUserData</code>,
        <code>isActive</code>, <code>activeGuestCount</code>. Не забувай про
        чутливість імен змінних до регістру. Змінні <code>isActive</code> та
        <code>IsActive</code> — це різні змінні.
      </p>
      <p>
        Варто пам'ятати, що існують зарезервовані
        <strong>ключові слова</strong>. Ці слова мають спеціальне значення та
        використовуються для певних конструкцій у мові. Не можна використовувати
        ключові слова як імена змінних, оскільки це спричинить помилки в коді.
      </p>
      <img
        src="../js/images/9f4e2b98-8e94-46de-a640-f03c05f39327m01-b02-s04.jpg"
        alt=""
      />

      <strong class="ql-size-large">Типові помилки</strong>
      <p>
        При виконанні коду можуть виникати помилки. Помилки відображаються в
        консолі інструментів розробника браузера.
      </p>
      <p>
        Ці помилки зазвичай містять описові повідомлення, які вказують на місце
        та причину помилки, допомагаючи зрозуміти, чому код не працює.
      </p>
      <img
        src="../js/images/0b526edb-7be8-4712-ae19-70ac14a95062Screenshot 2023-06-13 at 17.24.31.png"
        alt=""
      />
      <p>
        Використання консолі інструментів розробника та читання повідомлень про
        помилки є важливими інструментами для налагодження та покращення якості
        твого коду. Це допомагає краще зрозуміти причину виникнення проблем і
        вжити відповідних заходів для їх виправлення.
      </p>
      <p><strong>Неправильне ім’я змінної</strong></p>
      <p>
        Уявімо, що є помилка в імені змінної. У коді ми намагаємось отримати
        значення змінної <code>user</code>, яку ми не оголошували, оскільки
        оголошували ми <code>username</code>.
      </p>
      <p>
        Помилка буде відображена в консолі з відповідним описом проблеми. Це
        дозволяє тобі швидко виявити та виправити помилки у своєму коді.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >const username <span class="hljs-operator">=</span> <span class="hljs-string">"Mango"</span><span class="hljs-comment">;</span>
console.log(user)<span class="hljs-comment">; // ReferenceError: user is not defined</span></pre>
        <button class="copy"></button>
      </div>
      <img
        src="../js/images/3de3378e-813c-4a9b-969a-f5f941fb1ca3Screenshot 2023-06-13 at 17.32.00.png"
        alt=""
      />

      <strong>Звернення до змінної до її оголошення</strong>
      <p>
        Розробник звертається до змінної до того, як змінна була оголошена через
        <code>const</code> або <code>let</code>. У цьому разі з’явиться помилка
        про те, що неможливо отримати доступ до змінної до її ініціалізації.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-comment">// ❌ Неправильно, буде помилка</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(age); <span class="hljs-comment">// ReferenceError: age is not defined</span>
        
<span class="hljs-comment">// Оголошення змінної age</span>
let age = <span class="hljs-number">20</span>;
        
<span class="hljs-comment">// ✅ Правильно, звертаємося після оголошення</span>
age = <span class="hljs-number">25</span>;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(age); <span class="hljs-comment">// 25</span>
</pre>
        <button class="copy"></button>
      </div>
      <img
        src="../js/images/57954a3e-4b75-475a-8599-4af259b882ebScreenshot 2023-06-13 at 17.23.37.png"
        alt=""
      />

      <p>
        <strong>Перевизначення значення для змінної оголошеної через </strong
        ><code><strong>const</strong></code>
      </p>
      <p>
        При спробі перевизначити значення <code>const</code> змінної буде
        помилка про те, що неможливо змінити значення для такої змінної.
      </p>
      <img
        src="../js/images/18ff6d90-9020-4ce2-8e0b-a7b099b79ec3Screenshot 2023-06-13 at 17.22.40 (1).png"
        alt=""
      />

      <strong class="ql-size-large">Типи даних</strong>
      <p>
        Примітивні типи даних використовуються для зберігання та обробки різних
        видів інформації у програмі. Вони відіграють важливу роль у виконанні
        арифметичних операцій, порівнянь та логічних перевірок. JavaScript
        змінна не обмежена певним типом даних, тому може зберігати значення
        різних типів.
      </p>
      <p><strong>Number</strong></p>
      <p>
        Числа (Number) можуть бути позитивними чи негативними, цілими або
        дробовими. Ціла та дробова частини числа розділяються крапкою.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >const age <span class="hljs-operator">=</span> <span class="hljs-number">20</span><span class="hljs-comment">;</span>
const salary <span class="hljs-operator">=</span> <span class="hljs-number">3710.84</span><span class="hljs-comment">;</span>
</pre>
        <button class="copy"></button>
      </div>
      <pre class="ql-blockquote" spellcheck="false">
Зверни увагу, що якщо їх розділити комою, то буде помилка.</pre
      >

      <p><strong>String</strong></p>
      <p>
        Рядок (String) є послідовністю символів, вкладених в одинарні
        <code>''</code> або подвійні лапки <code>""</code>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-ebnf"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-attribute">const username</span> = <span class="hljs-string">'Mango995'</span>;
<span class="hljs-attribute">const description</span> = <span class="hljs-string">"JavaScript is awesome!"</span>;</pre>
        <button class="copy"></button>
      </div>

      <p><strong>Boolean</strong></p>
      <p>
        Логічний тип даних (Boolean) має лише два значення: <code>true</code> і
        <code>false</code>.
      </p>
      <ul class="ul">
        <li><code>true</code> — це логічне значення;</li>
        <li>
          <span style="background-color: rgb(236, 239, 241)">"</span
          ><code>true</code
          ><span style="background-color: rgb(236, 239, 241)">"</span> — це
          рядок, що містить слово true.
        </li>
      </ul>
      <p>
        Він використовується для виконання логічних операцій та перевірок умов.
        Наприклад, на запитання "чи ввімкнене світло в кімнаті?" можна
        відповісти "так" (true) або "ні" (false).
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >const isModalOpen <span class="hljs-operator">=</span> true<span class="hljs-comment">;</span>
const isLoggedIn <span class="hljs-operator">=</span> false<span class="hljs-comment">;</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>
        Зверни увагу, що імена змінних, що містять логічні значення, звучать як
        питання, на яке можна відповісти “так” чи “ні”.
      </p>

      <strong class="ql-size-large">Спеціальні значення</strong>
      <p>
        У JavaScript існують два спеціальні значення: <code>null</code> і
        <code>undefined</code>. Обидва означають відсутність значення.
      </p>
      <p>
        <code>null</code> явно вказує на відсутність значення та часто
        використовується розробниками для позначення порожнього значення. Це
        значення має бути явно присвоєно змінній, щоб вказати, що змінна не
        містить ніяких дійсних даних.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        >let value = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value); <span class="hljs-comment">// null</span>
</pre>
        <button class="copy"></button>
      </div>

      <p>
        Значення <code>undefined</code> автоматично присвоюється змінній, якщо:
      </p>
      <ul class="ul">
        <li>змінній було явно задано значення <code>undefined</code> ;</li>
        <li>змінна була оголошена, але ще не була ініціалізована значенням.</li>
      </ul>
      <p>
        Значення <code>undefined</code> вказує на невизначеність значення
        змінної, тобто каже нам, що значення на даний момент невідоме чи
        невизначене.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        >let value;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value); <span class="hljs-comment">// undefined</span></pre>
        <button class="copy"></button>
      </div>
      <pre class="ql-blockquote" spellcheck="false">
Хоча обидва значення <code>null</code> і <code>undefined</code> позначають відсутність значення, вони мають трохи різні семантики використання.
      — null використовується для явної вказівки порожнього значення (точно відомо, що значення немає).
      — undefined вказує на невизначеність значення змінної.
</pre
      >

      <p>
        <strong class="ql-size-large">Оператор </strong
        ><code class="ql-size-large"><strong>typeof</strong></code>
      </p>
      <p>
        Оператор <code>typeof</code> використовується для визначення типу даних
        значення або виразу.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-actionscript"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">typeof</span> operand</pre>
        <button class="copy"></button>
      </div>
      <p>
        Замість <code>operand</code> ти вказуєш змінну, літерал або вираз, тип
        якого ти хочеш визначити. Результатом оператора <code>typeof</code> буде
        рядок, який вказує тип даних.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        >const quantity = <span class="hljs-number">17</span>;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> quantity); <span class="hljs-comment">// виведе "number"</span>
        
const message = <span class="hljs-string">"JavaScript is awesome!"</span>;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> message); <span class="hljs-comment">// виведе "string"</span>
        
const isSidebarOpen = <span class="hljs-literal">false</span>;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> isSidebarOpen); <span class="hljs-comment">// виведе "boolean"</span>
        
let username;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> username); <span class="hljs-comment">// виведе "undefined"</span>
        
let status = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> status); <span class="hljs-comment">// виведе "object"</span></pre>
        <button class="copy"></button>
      </div>

      <p>
        Зверни увагу на перевірку типу значення <code>null</code>. Важливо
        розуміти, що <code>null</code> насправді є примітивним значенням, а не
        об'єктом.
      </p>
      <p>
        Коли ми використовуємо оператор <code>typeof</code> для перевірки типу
        значення <code>null</code>, він повертає рядок <code>object</code
        ><strong>.</strong> Це може здатися дивним, оскільки <code>null</code> —
        це фактично відсутність значення, а не об'єкт. Про це часто питають на
        співбесідах.
      </p>
      <p>
        Причина цього полягає в тому, що в ранніх версіях JavaScript
        <code>null</code> було розглянуто як спеціальний випадок об’єкта. Це
        була помилка в реалізації мови, збережена для забезпечення зворотної
        сумісності з існуючим кодом. Тому коли
        <code>typeof</code> застосовується до <code>null</code>, він повертає
        <code>object</code>, щоб зберегти цю сумісність.
      </p>

      <strong class="ql-size-large">Арифметичні операції</strong>
      <p>
        У JavaScript доступні різноманітні математичні оператори, які дозволяють
        виконувати арифметичні обчислення.
      </p>
      <img
        src="../js/images/84879003-1b3b-4c70-9cb2-4d9f1a3fb223m01-b02-s09.jpg"
        alt=""
      />
      <p>
        Працюючи з цими операторами, необхідно враховувати правила порядку
        виконання операцій. Ці правила аналогічні тим, які ми вивчали у шкільній
        алгебрі: спершу дії в дужках, потім степені й корені, потім множення та
        ділення тощо.
      </p>
      <p>
        Результатом операцій є значення, яке можна використовувати далі у
        виразах або зберегти у змінних.
      </p>
      <p>
        Оператор (<code>+</code>) використовується для складання двох чисел.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-gml"
          spellcheck="false"
          data-highlighted="yes"
        >const <span class="hljs-variable language_">x</span> = <span class="hljs-number">8</span>;
const <span class="hljs-variable language_">y</span> = <span class="hljs-number">5</span>;
console.log(<span class="hljs-variable language_">x</span> + <span class="hljs-variable language_">y</span>); <span class="hljs-comment">// 13</span></pre>
        <button class="copy"></button>
      </div>

      <p>
        Оператор (<code>-</code>) використовується для віднімання одного числа
        від іншого.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >const x <span class="hljs-operator">=</span> <span class="hljs-number">8</span><span class="hljs-comment">;</span>
const y <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-comment">;</span>
console.log(x - y)<span class="hljs-comment">; // 3</span></pre>
        <button class="copy"></button>
      </div>

      <p>Оператор (<code>*</code>) використовується для множення двох чисел.</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >const x <span class="hljs-operator">=</span> <span class="hljs-number">8</span><span class="hljs-comment">;</span>
const y <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-comment">;</span>
console.log(x * y)<span class="hljs-comment">; // 40</span></pre>
        <button class="copy"></button>
      </div>

      <p>
        Оператор (<code>/</code>) використовується для ділення одного числа на
        інше.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >const x <span class="hljs-operator">=</span> <span class="hljs-number">8</span><span class="hljs-comment">;</span>
const y <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-comment">;</span>
console.log(x / y)<span class="hljs-comment">; // 1.6</span></pre>
        <button class="copy"></button>
      </div>

      <p>
        Оператор (<code>%</code>) повертає остачу від ділення одного числа на
        інше.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >const x <span class="hljs-operator">=</span> <span class="hljs-number">8</span><span class="hljs-comment">;</span>
const y <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-comment">;</span>
console.log(x % y)<span class="hljs-comment">; // 3</span></pre>
        <button class="copy"></button>
      </div>

      <p>
        Оператор (<code>**</code>) використовується для піднесення числа до
        степеня.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >const x <span class="hljs-operator">=</span> <span class="hljs-number">8</span><span class="hljs-comment">;</span>
const y <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-comment">;</span>
console.log(x ** y)<span class="hljs-comment">; // 32768</span></pre>
        <button class="copy"></button>
      </div>

      <strong class="ql-size-large">Комбіновані оператори</strong>
      <p>
        Для всіх арифметичних операторів є еквівалентні комбіновані оператори.
        Вони дозволяють більш компактно виконувати арифметичні операції та
        одночасно оновлювати значення змінної, виходячи з її попереднього
        значення.
      </p>
      <p>Ось список арифметичних операторів та їх комбінованих еквівалентів:</p>
      <ul>
        <li>
          <strong>Додавання</strong>: <code><strong>+=</strong></code
          >. Приклад: <code><strong>x += y</strong></code> еквівалентно
          <code><strong>x = x + y</strong></code>
        </li>
      </ul>
      <ul>
        <li>
          <strong>Віднімання</strong>: <code>-=</code>. Приклад:
          <code><strong>x -= y</strong></code> еквівалентно
          <code><strong>x = x - y</strong></code>
        </li>
      </ul>
      <ul>
        <li>
          <strong>Множення</strong>: <code>*=</code>. Приклад:
          <code><strong>x *= y</strong></code> еквівалентно
          <code><strong>x = x * y</strong></code>
        </li>
      </ul>
      <ul>
        <li>
          <strong>Ділення</strong>: <code>/=</code>. Приклад:
          <code><strong>x /= y</strong></code> еквівалентно
          <code><strong>x = x / y</strong></code>
        </li>
      </ul>
      <ul>
        <li>
          <strong>Остача від ділення</strong>: <code><strong>%=</strong></code
          >. Приклад: <code><strong>x %= y</strong></code> еквівалентно
          <code><strong>x = x % y</strong></code>
        </li>
      </ul>
      <p>
        Давай розглянемо приклад оновлення віку користувача після дня
        народження, збільшуючи значення змінної <code>age</code> на одиницю.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-apache"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-attribute">let</span> age = <span class="hljs-number">25</span>;
<span class="hljs-attribute">age</span> = age + <span class="hljs-number">1</span>;
<span class="hljs-attribute">console</span>.log(age); // <span class="hljs-number">26</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Спочатку виконується додавання у правій частині виразу присвоєння.
        Складається поточне значення змінної <code>age</code>, яке дорівнює
        <code>25</code>, та <code>1</code>. Результат: <code>26</code>. Потім
        цей результат присвоюється як нове значення змінної <code>age</code>.
      </p>
      <p>
        Однак, ми можемо покращити цей код, використовуючи комбінований оператор
        присвоєння з додаванням (<code>+=</code>).
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-apache"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-attribute">let</span> age = <span class="hljs-number">25</span>;
<span class="hljs-attribute">age</span> += <span class="hljs-number">1</span>;
<span class="hljs-attribute">console</span>.log(age); // <span class="hljs-number">26</span></pre>
        <button class="copy"></button>
      </div>
    </section>
    <!--Рядки-->
    <section>
      <h2 id="message">Рядки</h2>
      <strong class="ql-size-large">Конкатенація рядків</strong>
      <p>
        Якщо застосувати оператор <code>+</code> до рядка та будь-якого іншого
        типу даних, результатом буде новий рядок, що містить об'єднання вихідних
        значень. Це називається конкатенація (склеювання).
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-sas"
          spellcheck="false"
          data-highlighted="yes"
        >const <span class="hljs-keyword">message</span> = <span class="hljs-string">"Mango "</span> + <span class="hljs-string">"is"</span> + <span class="hljs-string">" happy"</span>;
console.<span class="hljs-meta">log</span>(<span class="hljs-keyword">message</span>); // <span class="hljs-string">"Mango is happy"</span></pre>
        <button class="copy"></button>
      </div>
      <pre
        class="ql-blockquote"
        spellcheck="false"
      ><strong>Зверни увагу! </strong>
Рядки "Mango " і " happy" містять пробіли, щоб текст повідомлення був читабельним.</pre>
      <p>
        Під час конкатенації можна використовувати значення змінних, щоб
        складати рядки з динамічними значеннями. Для цього необхідно вказати
        ім'я змінної, у це місце буде підставлено її значення.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-ebnf"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-attribute">const age</span> = 24;
<span class="hljs-attribute">const message</span> = <span class="hljs-string">"Poly is "</span> + age + <span class="hljs-string">" years old!"</span>;</pre>
        <button class="copy"></button>
      </div>
      <p>
        Під час конкатенації будь-який тип даних буде приведено до рядка та
        поєднано з іншим рядком.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Mango"</span> + <span class="hljs-number">55</span>); <span class="hljs-comment">// "Mango55"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Mango"</span> + <span class="hljs-literal">true</span>); <span class="hljs-comment">// "Mangotrue"</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Проте порядок операндів має значення. Перетворення типів відбувається
        лише в момент операції додавання з рядком. До цього моменту
        застосовуються нормальні правила математики.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span> + <span class="hljs-string">"2"</span>); <span class="hljs-comment">// "12"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span> + <span class="hljs-string">"2"</span> + <span class="hljs-number">4</span>); <span class="hljs-comment">// "124"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-string">"4"</span>); <span class="hljs-comment">// "34"</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        В останньому прикладі спочатку виконується математичне додавання для
        перших двох чисел <code>1</code> і <code>2</code>, потім число
        <code>3</code> перетворюється на рядок <code>"3"</code> і поєднується з
        рядком <code>"4"</code>.
      </p>

      <strong class="ql-size-large">Перетворення типів: рядки</strong>
      <p>
        Перетворення типів у JavaScript — це процес зміни значення одного типу
        даних на інший тип даних. Перетворення типів може відбуватися в різних
        ситуаціях, наприклад, під час виконання арифметичних операцій з різними
        типами даних або порівняння значень. У JavaScript існують два типи
        перетворення: явне та неявне.
      </p>

      <p><strong>Явне перетворення типів</strong></p>
      <p>
        Явне перетворення типів виконується програмістом і використовується за
        потребою. Для перетворення будь-якого значення на рядок можна
        використовувати вбудовану функцію <code>String()</code>, яка повертає
        результат у вигляді рядка.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(String(<span class="hljs-number">5</span>)); <span class="hljs-comment">// "5"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(String(<span class="hljs-literal">true</span>)); <span class="hljs-comment">// "true"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(String(<span class="hljs-literal">false</span>)); <span class="hljs-comment">// "false"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(String(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// "null"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(String(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// "undefined"</span></pre>
        <button class="copy"></button>
      </div>

      <p><strong>Неявне перетворення типів</strong></p>
      <p>
        Неявне перетворення типів відбувається автоматично під час виконання
        операцій або обчислень. Наприклад, якщо виконується операція додавання
        (<code>+</code>) між рядком та іншим типом даних, JavaScript автоматично
        перетворює значення операнда на рядок і виконує конкатенацію рядків.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"5"</span> + <span class="hljs-number">3</span>); <span class="hljs-comment">// "53"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"5"</span> + <span class="hljs-literal">true</span>); <span class="hljs-comment">// "5true"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"5"</span> + <span class="hljs-literal">false</span>); <span class="hljs-comment">// "5false"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"5"</span> + <span class="hljs-literal">null</span>); <span class="hljs-comment">// "5null"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"5"</span> + <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// "5undefined"</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Неявне перетворення — це зручний вбудований механізм JavaScript, але
        іноді може викликати несподівані результати або помилки. Тому важливо
        бути уважним при виконанні операцій з різними типами даних і вчитися
        контролювати та бачити перетворення типів у коді своїх програм.
      </p>

      <strong class="ql-size-large">Шаблонні рядки</strong>
      <p>
        Шаблонні рядки — це синтаксис, який полегшує об'єднання
        <strong>статичного</strong> тексту з <strong>динамічним</strong> (тобто
        текстом, що містить змінні, обчислення тощо). Шаблонні рядки дозволяють
        уникати користування заплутаною конкатенацією та роблять код більш
        читабельним.
      </p>

      <p><strong>Синтаксис шаблонного рядка</strong></p>
      <p>
        Шаблонні рядки огортаються зворотними лапками (англ. backticks)
        (<code>``</code>)
      </p>
      <pre class="ql-blockquote" spellcheck="false"><strong>Увага! </strong>
        Код не працюватиме, якщо огорнути шаблонні рядки звичайними одинарними або подвійними лапками.</pre>
      <p>
        Для того щоб додати зворотні лапки <code>``</code>, перейди в англійську
        розкладку та натисни
      </p>
      <ul class="ul">
        <li>клавішу <code>~</code> (див. 1-3 нижче)</li>
      </ul>
      <p>або</p>
      <ul class="ul">
        <li>поєднання клавіш (див. 4 нижче)</li>
      </ul>
      <img
        src="../js/images/0090b650-ad6b-4e09-a3cb-b8283ba92dfdm01-b03-s03.jpg"
        alt=""
      />
      <p>
        Шаблонні рядки дозволяють підставляти значення змінних безпосередньо
        всередині рядка за допомогою синтаксису інтерполяції
        <code>${змінна}</code>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-javascript"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">const</span> guestName = <span class="hljs-string">"Mango"</span>;
<span class="hljs-keyword">const</span> roomNumber = <span class="hljs-number">207</span>;
<span class="hljs-keyword">const</span> greeting = <span class="hljs-string">`Welcome <span class="hljs-subst">${guestName}</span>, your room number is <span class="hljs-subst">${roomNumber}</span>!`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting); <span class="hljs-comment">// "Welcome Mango, your room number is 207!"</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        У прикладі вище ми використали інтерполяцію (конструкцію
        <code>${}</code>) для того, щоб підставити значення змінних
        <code>guestName</code> та <code>roomNumber</code> прямо в текст рядка.
        Під час формування цього рядка значення змінних автоматично
        підставляться в місцях, де є відповідна інтерполяція.
      </p>

      <strong>Порівняння конкатенації та шаблонних рядків</strong>
      <p>Код з конкатенацією, де</p>
      <ul class="ul">
        <li>
          "<em>Welcome</em> " "<em>, your room number is</em> " та "<em>!</em>"
          — це статичний текст
        </li>
        <li>
          <code>guestName</code> та <code>roomNumber</code> — імена змінних.
        </li>
      </ul>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-cpp"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-type">const</span> guestName = <span class="hljs-string">"Mango"</span>;
<span class="hljs-type">const</span> roomNumber = <span class="hljs-number">207</span>;
<span class="hljs-type">const</span> greeting =
  <span class="hljs-string">"Welcome "</span> + guestName + <span class="hljs-string">", your room number is "</span> + roomNumber + <span class="hljs-string">"!"</span>;
console.<span class="hljs-built_in">log</span>(greeting); <span class="hljs-comment">// "Welcome Mango, your room number is 207!"</span></pre>
        <button class="copy"></button>
      </div>
      <p>Код, де значення цих змінних підставляються у шаблонний рядок.</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-javascript"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">const</span> guestName = <span class="hljs-string">"Mango"</span>;
<span class="hljs-keyword">const</span> roomNumber = <span class="hljs-number">207</span>;
<span class="hljs-keyword">const</span> greeting = <span class="hljs-string">`Welcome <span class="hljs-subst">${guestName}</span>, your room number is <span class="hljs-subst">${roomNumber}</span>!`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting); <span class="hljs-comment">// "Welcome Mango, your room number is 207!"</span></pre>
        <button class="copy"></button>
      </div>
      <p>Код шаблонних рядків є більш читабельним.</p>

      <strong class="ql-size-large">Довжина рядка</strong>
      <p>Властивості — це описові характеристики сутності.</p>
      <p>
        Для опису людини часто використовують такі властивості, як зріст, вага
        або колір очей.
      </p>
      <p>Для опису даних також використовуються властивості.</p>
      <p>
        Для доступу до властивості (<code>property</code>) сутності
        (<code>objectName</code>) використовується синтаксис із крапкою:
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-undefined"
          spellcheck="false"
          data-highlighted="yes"
        >
сутність.властивість</pre
        >
        <button class="copy"></button>
      </div>
      <p>
        У програмуванні, наприклад, рядок має властивість <code>length</code>,
        яка повертає довжину рядка.
      </p>
      <p>
        Довжина рядка визначається кількістю символів у ньому. Щоб дізнатися
        довжину рядка, використовується вбудована властивість
        <code>length</code>. Щоб отримати значення цієї властивості, необхідно
        звернутися до неї через крапку після імені змінної чи рядкового
        літералу.
      </p>
      <p>
        Наприклад, щоб отримати довжину рядка, ми можемо використовувати
        властивість <code>length</code> таким чином:
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        >const productName = <span class="hljs-string">"Repair droid"</span>;

<span class="hljs-comment">// Якщо у змінній зберігається рядок</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(productName.<span class="hljs-built_in">length</span>); <span class="hljs-comment">// 12</span>
        
<span class="hljs-comment">// Якщо рядковий літерал</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Repair droid"</span>.<span class="hljs-built_in">length</span>); <span class="hljs-comment">// 12</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Використання властивості <code>length</code> дозволяє легко визначити
        довжину будь-якого рядка та використовувати цю інформацію для виконання
        різних операцій і перевірок.
      </p>

      <strong class="ql-size-large">Індексація рядків</strong>
      <p>
        Рядки — це набори символів, де кожен символ має свій порядковий номер
        (індекс). Індексація елементів рядка починається з нуля. Перший символ
        має індекс 0, другий — індекс 1, третій — 2 і так далі.
      </p>

      <img
        src="../js/images/72eb24ab-b422-4ed8-afb7-1c03955121d7m01-b03-s06.jpg"
        alt=""
      />
      <p>
        Наприклад, у рядку <code>"JavaScript"</code> буква <code>J</code> стоїть
        на позиції з індексом <code>0</code>.
      </p>
      <p>Буква <code>t</code> йде під індексом <code>9</code>.</p>
      <p>
        Загальна довжина рядка <code>"JavaScript"</code> дорівнює
        <code>10</code>, тобто індекс останнього елемента рядка завжди на
        одиницю менше його довжини.
      </p>
      <p>
        Для доступу до певного символу рядка ми використовуємо синтаксис
        квадратних дужок, де вказуємо індекс потрібного символу:
        <code>string[index]</code>, тобто <strong>рядок[індекс]</strong>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        >const product = <span class="hljs-string">"Repair droid"</span>;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(product[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 'R'</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(product[<span class="hljs-number">5</span>]); <span class="hljs-comment">// 'r'</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(product[<span class="hljs-number">11</span>]); <span class="hljs-comment">// 'd'</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Отримання останнього символу рядка можливе за його індексом
        <code>string[lastIndex]</code>. Щоб знайти індекс останнього символу
        рядка, треба від довжини цього рядка відняти одиницю
        <code>string.length - 1</code>
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >const product <span class="hljs-operator">=</span> <span class="hljs-string">"Repair droid"</span><span class="hljs-comment">;</span>
const lastElementIndex <span class="hljs-operator">=</span> product.length - <span class="hljs-number">1</span><span class="hljs-comment">;</span>
console.log(product[lastElementIndex])<span class="hljs-comment">; // 'd'</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Для доступу до останнього символу рядка без створення проміжної змінної
        ми можемо вставити вираз (<code>product.length - 1</code>) безпосередньо
        у квадратні дужки при зверненні до елемента.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-maxima"
          spellcheck="false"
          data-highlighted="yes"
        >const <span class="hljs-built_in">product</span> = <span class="hljs-string">"Repair droid"</span>;
console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">product</span>[<span class="hljs-built_in">product</span>.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>]); // 'd'</pre>
        <button class="copy"></button>
      </div>

      <strong class="ql-size-large">Незмінність рядків</strong>
      <p>
        Коли рядок створюється, він зберігає своє значення і стає незмінним. Це
        означає, що не можна замінити окремі символи всередині рядка.
      </p>
      <p>
        Уяви, що маємо рядок "Droid". Ми не можемо змінити окремий символ у
        цьому рядку, наприклад, замінити 'o' на 'O'. Спроба надання нового
        значення елементу рядка не призведе до зміни вихідного рядка.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-maxima"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">let</span> <span class="hljs-built_in">product</span> = <span class="hljs-string">"Droid"</span>;
console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">product</span>); // <span class="hljs-string">"Droid"</span>
        
// Це не має жодного ефекту
<span class="hljs-built_in">product</span>[<span class="hljs-number">2</span>] = <span class="hljs-string">"O"</span>;
console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">product</span>); // <span class="hljs-string">"Droid"</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Натомість ми повинні створити новий рядок і присвоїти його змінній
        замість старого рядка.
      </p>
      <p>
        Розгляньмо приклад, де змінено написання о —&gt; О в рядку
        <code>“Droid”</code>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-maxima"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">let</span> <span class="hljs-built_in">product</span> = <span class="hljs-string">"Droid"</span>;
console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">product</span>); // <span class="hljs-string">"Droid"</span>
        
<span class="hljs-built_in">product</span> = <span class="hljs-string">"DrOid"</span>;
console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">product</span>); // <span class="hljs-string">"DrOid"</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Ця властивість незмінності рядків у JavaScript має важливе значення для
        забезпечення надійності та запобігання випадковим змінам усередині
        рядків.
      </p>
    </section>
    <!--Оператори порівняння-->
    <section>
      <h2 id="operators">Оператори порівняння</h2>
      <p>
        Оператори порівняння використовуються для порівняння двох значень і
        повертають булеве значення (<code>true</code> або <code>false</code>)
        залежно від результату порівняння.
      </p>
      <p>Ось деякі основні оператори порівняння:</p>
      <ul class="ul">
        <li>
          Оператор <code>&gt;</code> (більше) — повертає <code>true</code>, якщо
          <strong>лівий</strong> операнд <strong>більше</strong> правого. В
          іншому разі повертає <code>false</code> .
        </li>
      </ul>
      <ul class="ul">
        <li>
          Оператор <code>&lt;</code> (менше) — повертає <code>true</code>, якщо
          <strong>лівий</strong> операнд <strong>менше</strong> правого. В
          іншому разі повертає <code>false</code> .
        </li>
      </ul>
      <ul class="ul">
        <li>
          Оператор <code>&gt;=</code> (більше або дорівнює) — повертає
          <code>true</code>, якщо <strong>лівий</strong> операнд
          <strong>більше або дорівнює</strong> правому. Якщо навпаки, повертає
          <code>false</code> .
        </li>
      </ul>
      <ul class="ul">
        <li>
          Оператор <code>&lt;=</code> (менше або дорівнює) — повертає
          <code>true</code>, якщо <strong>лівий</strong> операнд
          <strong>менше або дорівнює</strong> правому. Якщо навпаки, повертає
          <code>false</code> .
        </li>
      </ul>
      <p>Давай розглянемо приклади використання цих операторів:</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        >const a = <span class="hljs-number">2</span>;
const b = <span class="hljs-number">5</span>;
        
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a &gt; b); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b &gt; a); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a &gt;= b); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b &gt;= a); <span class="hljs-comment">// true</span>
        
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a &lt; b); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b &lt; a); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a &lt;= b); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b &lt;= a); <span class="hljs-comment">// false</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Основний принцип використання операторів порівняння полягає в тому, щоб
        порівнювати значення та отримувати булевий результат. Булевий результат
        (результат у вигляді <code>true</code> або <code>false</code>) дозволяє
        приймати певні рішення та контролювати поведінку програми відповідно до
        умов.
      </p>
      <p>
        Оператори порівняння часто використовуються в умовних виразах або
        циклах, для перевірки умов та виконання певних дій на основі результатів
        порівняння. Наприклад, користувачі, старші за 18 років, отримують доступ
        до певної групи товарів.
      </p>

      <strong class="ql-size-large">Оператори рівності</strong>
      <p>
        У JavaScript існують оператори рівності, які дозволяють порівнювати
        значення та визначати їхню рівність або нерівність.
      </p>
      <p>Оператори <strong>несуворої</strong> рівності:</p>
      <ul class="ul">
        <li>
          Оператор <code><strong>==</strong></code> (дорівнює) — порівнює два
          значення на рівність і повертає <code>true</code>, якщо
          <strong>значення операндів рівні.</strong> Якщо навпаки, повертає
          <code>false</code>
        </li>
      </ul>
      <ul class="ul">
        <li>
          Оператор <code>!=</code> (не дорівнює) — порівнює два значення на
          нерівність і повертає <code>true</code>, якщо
          <strong>значення операндів не рівні.</strong> Якщо навпаки, повертає
          <code>false</code>
        </li>
      </ul>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> == <span class="hljs-number">5</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> == <span class="hljs-number">3</span>); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> != <span class="hljs-number">3</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> != <span class="hljs-number">5</span>); <span class="hljs-comment">// false</span></pre>
        <button class="copy"></button>
      </div>

      <p><strong>Але є одна проблема.</strong></p>
      <p>
        Оператори несуворої рівності можуть приводити значення до різних типів,
        в залежності від контексту порівняння. Це може призвести до неочікуваних
        результатів, тому багато розробників намагаються уникати їх
        використання.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-comment">// Погано, бо виконується неявне приведення рядків і булевого значення до числа</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> == <span class="hljs-string">"5"</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> != <span class="hljs-string">"5"</span>); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span> == <span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span> != <span class="hljs-literal">true</span>); <span class="hljs-comment">// false</span></pre>
        <button class="copy"></button>
      </div>
      <p>Розглянемо ці приклади детальніше.</p>
      <p>
        Вираз <code>5 == "5"</code> поверне <code>true</code>, хоча одне зі
        значень є числом, а інше — рядком. Рядок <code>"5"</code> буде
        приведений до числа <code>5</code>, і порівняння виглядає як
        <code>5 == 5</code>. Аналогічно, вираз <code>1 == true</code> поверне
        <code>true</code>, бо булеве значення <code>true</code> приводиться до
        числа <code>1</code>.
      </p>
      <p>
        На наступній ілюстрації показано таблицю порівняння значень, із
        використанням операторів несуворої рівності.
      </p>
      <img
        src="../js/images/2a95447d-3c0f-4d4a-9f85-f0d80da68f97m01-b04-s02.jpg"
        alt=""
      />
      <p>
        Неявне перетворення типів може призводити до помилок, особливо в
        розробників-початківців. Для уникнення таких проблем рекомендується
        використовувати оператори суворої рівності, які не виконують
        перетворення типів операндів.
      </p>
      <ul class="ul">
        <li>
          Оператор <code><strong>===</strong></code> (сувора рівність) —
          порівнює два значення на рівність, повертає <code>true</code>, якщо
          <strong>значення операндів рівні</strong> та мають
          <strong>однаковий тип даних.</strong> В іншому випадку, повертає
          <code>false</code>
        </li>
      </ul>

      <ul class="ul">
        <li>
          Оператор <code><strong>!==</strong></code> (сувора нерівність) —
          порівнює два значення на нерівність, повертає <code>true</code>, якщо
          значення операндів <strong>не рівні</strong> або мають
          <strong>різні типи даних.</strong> В іншому випадку, повертає
          <code>false</code>
        </li>
      </ul>

      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-comment">// Добре, приведення типів не виконується</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> === <span class="hljs-number">5</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> === <span class="hljs-string">"5"</span>); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> !== <span class="hljs-string">"5"</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> !== <span class="hljs-number">5</span>); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span> === <span class="hljs-literal">true</span>); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span> !== <span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        На відміну від несуворих операторів, вирази <code>5 === "5"</code> і
        <code>1 === true</code> повернуть <code>false</code>, тому що операнди
        мають різні типи.
      </p>
      <p>
        На наступній ілюстрації показано таблицю порівняння значень із
        використанням операторів суворої рівності. Усі операнди дорівнюють лише
        самі собі. Перед порівнянням нічого не перетворюється на інший тип.
      </p>
      <img
        src="../js/images/0c2a88d4-6d32-4c51-ae9e-f91eaa7c2621m01-b04-s02(2).jpg"
        alt=""
      />

      <strong class="ql-size-large">Перетворення типів: числа</strong>
      <p>
        У деяких операціях виконується явне або неявне перетворення значень
        операндів до числа.
      </p>
      <p>
        Для явного перетворення будь-якого значення в число можна
        використовувати вбудовану функцію <code>Number()</code>, яка повертає
        результат у вигляді числа.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-string">"5"</span>)); <span class="hljs-comment">// 5</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>)); <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>)); <span class="hljs-comment">// 0</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// 0</span></pre>
        <button class="copy"></button>
      </div>

      <p>При перетворенні до числа:</p>
      <ul class="ul">
        <li><code>true</code> завжди приводиться до <code>1</code>;</li>
        <li>
          <code>false</code> , <code>null</code> і <code>""</code> завжди
          приводяться до <code>0</code>.
        </li>
      </ul>
      <p>
        Якщо неможливо привести значення до числа, результатом перетворення буде
        спеціальне значення <code>NaN</code> (Not a Number). Ось кілька
        прикладів, коли результатом перетворення буде <code>NaN</code>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// NaN</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-string">"Jacob"</span>)); <span class="hljs-comment">// NaN</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-string">"25px"</span>)); <span class="hljs-comment">// NaN</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Арифметичні операції (<code>+</code>, <code>-</code>,
        <code><strong>*</strong></code
        >, <code>/</code>) виконують неявне перетворення типів.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"5"</span> * <span class="hljs-number">2</span>); <span class="hljs-comment">// 10</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"10"</span> - <span class="hljs-number">5</span>); <span class="hljs-comment">// 5</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> + <span class="hljs-literal">true</span>); <span class="hljs-comment">// 6</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> - <span class="hljs-literal">true</span>); <span class="hljs-comment">// 4</span></pre>
        <button class="copy"></button>
      </div>
      <ul class="ul">
        <li>
          Якщо у виразі присутній хоча б один із операндів з типом рядка, то
          обидва операнди приводяться до чисел. Це відбувається у всіх
          арифметичних операціях, окрім додавання. Пам’ятай, що + біля рядкових
          операндів викликає їх з'єднання (конкатинацію).
        </li>
      </ul>
      <ul class="ul">
        <li>
          Для всіх інших типів операндів та операцій виконується перетворення
          операндів до числа.
        </li>
      </ul>
      <p>
        У разі використання операторів порівняння (<code
          ><strong>&lt;</strong></code
        >, <code><strong>&gt;</strong></code
        >, <code><strong>&lt;=</strong></code
        >, <code><strong>&gt;=</strong></code
        >) також виконується неявне перетворення типів. Якщо операнди різних
        типів, то перед порівнянням вони приводяться до числа.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"10"</span> &gt; <span class="hljs-number">5</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">10</span> &gt; <span class="hljs-string">"5"</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> &gt; <span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> &lt; <span class="hljs-literal">true</span>); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"5"</span> &lt; <span class="hljs-literal">true</span>); <span class="hljs-comment">// false</span></pre>
        <button class="copy"></button>
      </div>

      <strong class="ql-size-large">Перетворення рядків у числа</strong>
      <p>
        <strong>Метод </strong><code><strong>Number.parseInt()</strong></code>
      </p>
      <p>Метод <code>Number.parseInt()</code> приймає 2 аргументи:</p>
      <ol class="ol">
        <li>
          Рядок. Якщо аргумент не є рядком, то він буде спочатку перетворений у
          рядок
        </li>
        <li>
          Система числення, до якої відноситься рядок (не обов’язковий аргумент,
          за замовчуванням десяткова система). Наприклад, для десяткової системи
          буде 10, для шістнадцяткової - 16 тощо..
        </li>
      </ol>
      <p>
        Метод аналізує рядок зліва направо, видаляючи пробіли на початку і
        перетворюючи допустимі символи у число до тих пір, поки не зіткнеться з
        першим недопустимим символом. Після цього аналіз припиняється, і вже
        перетворене ціле число повертається.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-coffeescript"
          spellcheck="false"
          data-highlighted="yes"
        >console.log(<span class="hljs-built_in">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"5"</span>)); <span class="hljs-regexp">//</span> <span class="hljs-number">5</span> 
console.log(<span class="hljs-built_in">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"5.5"</span>)); <span class="hljs-regexp">//</span> <span class="hljs-number">5</span> 
console.log(<span class="hljs-built_in">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"5cm"</span>)); <span class="hljs-regexp">//</span> <span class="hljs-number">5</span> 
console.log(<span class="hljs-built_in">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"12qwe74"</span>)); <span class="hljs-regexp">//</span> <span class="hljs-number">12</span> 
console.log(<span class="hljs-built_in">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"12.46qwe79"</span>)); <span class="hljs-regexp">//</span> <span class="hljs-number">12</span> 
console.log(<span class="hljs-built_in">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"cm5"</span>)); <span class="hljs-regexp">//</span> <span class="hljs-literal">NaN</span> 
console.log(<span class="hljs-built_in">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">""</span>)); <span class="hljs-regexp">//</span> <span class="hljs-literal">NaN</span> 
console.log(<span class="hljs-built_in">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"qweqwe"</span>)); <span class="hljs-regexp">//</span> <span class="hljs-literal">NaN</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Якщо перші символи рядка не можуть бути перетворені на число, або рядок
        порожній чи відсутній, результатом буде значення <code>NaN</code> (Not a
        Number).
      </p>

      <p>
        <strong>Метод </strong><code><strong>Number.parseFloat()</strong></code>
      </p>
      <p>
        Метод <code>Number.parseFloat()</code> аналогічний
        <code>Number.parseInt()</code> з однієї відмінністю: перетворює рядок на
        число з плаваючою крапкою.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>.parseFloat(<span class="hljs-string">"5"</span>)); <span class="hljs-comment">// 5</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>.parseFloat(<span class="hljs-string">"5.5"</span>)); <span class="hljs-comment">// 5.5</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>.parseFloat(<span class="hljs-string">"3.14"</span>)); <span class="hljs-comment">// 3.14</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>.parseFloat(<span class="hljs-string">"5cm"</span>)); <span class="hljs-comment">// 5</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>.parseFloat(<span class="hljs-string">"5.5cm"</span>)); <span class="hljs-comment">// 5.5</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>.parseFloat(<span class="hljs-string">"12qwe74"</span>)); <span class="hljs-comment">// 12</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>.parseFloat(<span class="hljs-string">"12.46qwe79"</span>)); <span class="hljs-comment">// 12.46</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>.parseFloat(<span class="hljs-string">"cm5"</span>)); <span class="hljs-comment">// NaN</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>.parseFloat(<span class="hljs-string">""</span>)); <span class="hljs-comment">// NaN</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>.parseFloat(<span class="hljs-string">"qweqwe"</span>)); <span class="hljs-comment">// NaN</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Якщо перші символи рядка не можуть бути перетворені на число, або рядок
        порожній чи відсутній, результатом буде значення
        <code style="background-color: rgba(135, 131, 120, 0.15)">NaN</code>
        (Not a Number).
      </p>

      <strong class="ql-size-large">Арифметичні функції</strong>
      <p>
        Клас <code>Math</code> є вбудованим класом JavaScript. Цей клас надає
        набір методів для виконання математичних операцій та роботи з числами.
        Ось кілька найбільш корисних методів, які надає клас <code>Math</code>:
      </p>
      <p>
        <code>Math.floor(num)</code>: повертає найближче ціле число, яке є
        меншим або дорівнює вказаному числу <code>num</code>. Наприклад:
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">floor</span>(<span class="hljs-number">1.3</span>)); <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">floor</span>(<span class="hljs-number">1.7</span>)); <span class="hljs-comment">// 1</span></pre>
        <button class="copy"></button>
      </div>

      <p>
        <code>Math.ceil(num)</code>: повертає найближче ціле число, яке є
        більшим, або дорівнює зазначеному числу <code>num</code>. Наприклад:
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">ceil</span>(<span class="hljs-number">1.3</span>)); <span class="hljs-comment">// 2</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">ceil</span>(<span class="hljs-number">1.7</span>)); <span class="hljs-comment">// 2</span></pre>
        <button class="copy"></button>
      </div>

      <p>
        <code>Math.round(num)</code>: повертає
        <strong>значення числа після округлення</strong> до найближчого цілого.
        Округлення відбувається за математичними правилами, якщо десяткова
        частина числа менша 0.5, то округлення буде в меншу сторону, якщо 0.5 і
        більше — то в більшу.
      </p>
      <p>Наприклад:</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">round</span>(<span class="hljs-number">1.3</span>)); <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">round</span>(<span class="hljs-number">1.7</span>)); <span class="hljs-comment">// 2</span></pre>
        <button class="copy"></button>
      </div>

      <p>
        <code>Math.max(num1, num2, ...)</code>: повертає
        <strong>найбільше</strong> число з набору переданих чисел. Наприклад:
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-apache"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-attribute">console</span>.log(Math.max(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>)); // <span class="hljs-number">50</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        <code>Math.min(num1, num2, ...)</code>: повертає
        <strong>найменше</strong> число з набору переданих чисел. Наприклад:
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-apache"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-attribute">console</span>.log(Math.min(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>)); // <span class="hljs-number">10</span></pre>
        <button class="copy"></button>
      </div>

      <p>
        <code>Math.random()</code>: повертає <strong>випадкове</strong> число в
        діапазоні від 0 (включно) до 1 (за винятком). Наприклад:
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-apache"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-attribute">console</span>.log(Math.random()); // випадкове число між <span class="hljs-number">0</span> і <span class="hljs-number">1</span>, наприклад <span class="hljs-number">0</span>.<span class="hljs-number">2</span> ... <span class="hljs-number">0</span>.<span class="hljs-number">9166353649342294</span></pre>
        <button class="copy"></button>
      </div>

      <p>
        Це лише деякі методи класу <code>Math</code>. Він також надає методи для
        тригонометричних функцій, логарифмів та інших математичних операцій. Ви
        можете звернутися до документації JavaScript для отримання повного
        списку методів класу <code>Math</code> і більш детального опису кожного
        з них.
      </p>

      <strong class="ql-size-large">Дробове число</strong>
      <p>
        При виконанні операцій з дробовими числами можуть виникати неточності
        через внутрішнє представлення чисел у пам'яті комп'ютера.
      </p>
      <p>
        Наприклад, результат <code>0.1 + 0.2</code> не дорівнює
        <code>0.3</code>. Число <code>0.1</code> у двійковій системі числення,
        яку використовує комп'ютер — це нескінченний дріб. Двійкове значення
        нескінченних дробів зберігається лише до певного знака, тому виникає
        неточність. При додаванні <code>0.1</code> і <code>0.2</code> дві
        неточності складаються, виходить незначна, але все ж таки помилка в
        обчисленнях.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-apache"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-attribute">console</span>.log(<span class="hljs-number">0</span>.<span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">2</span> === <span class="hljs-number">0</span>.<span class="hljs-number">3</span>); // false
<span class="hljs-attribute">console</span>.log(<span class="hljs-number">0</span>.<span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">2</span>); // <span class="hljs-number">0</span>.<span class="hljs-number">30000000000000004</span></pre>
        <button class="copy"></button>
      </div>
      <p>Як виправити цю проблему?</p>
      <p>
        Залежно від необхідної точності, можна використовувати різні підходи.
      </p>

      <p><strong>Підхід 1.</strong></p>
      <ul class="ul">
        <li>Помножити числа на досить велике число (наприклад, 10 або 100).</li>
        <li>Виконати додавання.</li>
        <li>
          Розділити результат на те саме число, щоб повернути його до
          початкового масштабу.
        </li>
      </ul>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-apache"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-attribute">console</span>.log(<span class="hljs-number">0</span>.<span class="hljs-number">1</span> * <span class="hljs-number">10</span> + <span class="hljs-number">0</span>.<span class="hljs-number">2</span> * <span class="hljs-number">10</span>); // <span class="hljs-number">3</span>
<span class="hljs-attribute">console</span>.log((<span class="hljs-number">0</span>.<span class="hljs-number">1</span> * <span class="hljs-number">10</span> + <span class="hljs-number">0</span>.<span class="hljs-number">2</span> * <span class="hljs-number">10</span>) / <span class="hljs-number">10</span>); // <span class="hljs-number">0</span>.<span class="hljs-number">3</span></pre>
        <button class="copy"></button>
      </div>

      <p><strong>Підхід 2.</strong></p>
      <p>
        Використовувати метод числа <code>toFixed()</code> для округлення
        результату до певної кількості знаків після крапки.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-apache"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-attribute">console</span>.log((<span class="hljs-number">0</span>.<span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">2</span>).toFixed(<span class="hljs-number">1</span>)); // <span class="hljs-string">"0.3"</span>
<span class="hljs-attribute">console</span>.log((<span class="hljs-number">5</span>).toFixed(<span class="hljs-number">2</span>));  //  ”<span class="hljs-number">5</span>.<span class="hljs-number">00</span>”
<span class="hljs-attribute">console</span>.log((<span class="hljs-number">8</span>.<span class="hljs-number">762195</span>).toFixed(<span class="hljs-number">4</span>));  //  “<span class="hljs-number">8</span>.<span class="hljs-number">7622</span>”</pre>
        <button class="copy"></button>
      </div>
      <p>
        Метод <code>toFixed()</code> повертає рядок, що представляє число із
        зазначеною кількістю знаків після крапки. Таким чином, ми можемо
        отримати заокруглений результат з необхідною точністю.
      </p>
    </section>
    <!--Основи функцій-->
    <section>
      <h2 id="functions">Основи функцій</h2>
      <strong class="ql-size-large">Оголошення та виклик функції</strong>
      <p>
        Функція — це незалежний блок коду, який виконує певну задачу з різними
        початковими значеннями.
      </p>
      <p>
        Функцію можна представити, як чорну скриньку, яка приймає дані на вході
        та повертає результат на виході після виконання коду всередині функції.
      </p>
      <img
        src="../js/images/9668a71a-4bed-4619-b793-d8ec93efbe69m01-b05-s01.jpg"
        alt=""
      />

      <strong>Оголошення функції</strong>
      <p>Оголошення функції має таку структуру:</p>
      <ol class="ol">
        <li>Ключове слово <code>function</code></li>
        <li>
          Ім'я функції — це дієслово, що відповідає на питання "Що зробити?"
        </li>
        <li>Пара круглих дужок <code>()</code></li>
        <li>Тіло функції у фігурних дужках <code>{}</code></li>
      </ol>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">function</span> <span class="hljs-title function_">doStuff</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Тіло функції</span>
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">'Log inside multiply function'</span>);
}</pre>
        <button class="copy"></button>
      </div>
      <p>
        Тіло функції міститься у фігурних дужках <code>{}</code>. Воно містить
        інструкції, які потрібно виконати під час виклику функції. Ці інструкції
        можуть включати оператори, умовні конструкції, цикли та інші функції.
      </p>

      <p><strong>Виклик функції</strong></p>
      <p>
        Коли функцію потрібно виконати, вона викликається за допомогою її імені
        та пари круглих дужок.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-scss"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-comment">// Оголошення функції multiply</span>
function <span class="hljs-built_in">doStuff</span>() {
  <span class="hljs-comment">// Тіло функції</span>
  console<span class="hljs-selector-class">.log</span>('Log inside multiply function');
}
        
<span class="hljs-comment">// Виклики функції multiply</span>
<span class="hljs-built_in">doStuff</span>(); <span class="hljs-comment">// 'Log inside multiply function'</span>
<span class="hljs-built_in">doStuff</span>(); <span class="hljs-comment">// 'Log inside multiply function'</span>
<span class="hljs-built_in">doStuff</span>(); <span class="hljs-comment">// 'Log inside multiply function'</span></pre>
        <button class="copy"></button>
      </div>

      <strong class="ql-size-large">Параметри та аргументи</strong>
      <p>
        У круглих дужках після імені функції вказуються параметри. Параметри є
        перерахуванням даних, які очікує функція під час виклику.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-comment">// Оголошення параметрів x, y, z</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">x, y, z</span>) {
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`Result: <span class="hljs-subst">${x * y * z}</span>`</span>);
}</pre>
        <button class="copy"></button>
      </div>
      <p>
        <strong>Параметри</strong> — це локальні змінні, доступні лише всередині
        тіла функції.
      </p>
      <p>
        Параметри розділяються комами. Функція може мати будь-яку кількість
        параметрів або не мати їх взагалі, у такому випадку вказуються просто
        порожні круглі дужки.
      </p>
      <p>
        Під час виклику функції в круглих дужках можна передати
        <strong>аргументи</strong>, які є значеннями для оголошених параметрів
        функції.
      </p>

      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-scss"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-comment">// Оголошення параметрів x, y, z</span>
function <span class="hljs-built_in">multiply</span>(x, y, z) {
  console<span class="hljs-selector-class">.log</span>(`Result: ${x * y * z}`);
}
        
<span class="hljs-comment">// Передача аргументів</span>
<span class="hljs-built_in">multiply</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// "Result: 30"</span>
<span class="hljs-built_in">multiply</span>(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">// "Result: 384"</span>
<span class="hljs-built_in">multiply</span>(<span class="hljs-number">17</span>, <span class="hljs-number">6</span>, <span class="hljs-number">25</span>); <span class="hljs-comment">// "Result: 2550"</span></pre>
        <button class="copy"></button>
      </div>

      <p>Отже, у прикладі вище маємо параметри x, y, z.</p>
      <p>
        Під час кожного виклику функції параметр може отримувати нове значення з
        аргументів. Наприклад, параметр <code>x</code> спочатку отримав значення
        2, потім 4, потім 17.
      </p>
      <img
        src="../js/images/13ecbe6a-d339-4d3b-a21e-240d30b221cbm01-b05-s02.jpg"
        alt=""
      />
      <p>
        При передачі аргументів під час виклику функції необхідно дотримуватись
        порядку, що відповідає порядку оголошених параметрів: значення першого
        аргументу буде присвоєно першому параметру, другого аргументу — другому
        параметру і так далі.
      </p>
      <p>
        Щоразу під час виклику функції параметри будуть оголошуватися заново, і
        їх значення в окремих викликах функції не впливатимуть один на одний.
      </p>

      <strong class="ql-size-large">Повернення значення</strong>
      <p>
        Оператор <code>return</code> використовується для повернення значення з
        тіла функції назад у код, у місце її виклику. Коли інтерпретатор
        зустрічає оператор <code>return</code>, він негайно виходить із функції
        (припиняє її виконання) і повертає вказане після return значення в місце
        виклику функції.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-gml"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">function</span> multiply(<span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>, z) {
  const product = <span class="hljs-variable language_">x</span> * <span class="hljs-variable language_">y</span> * z;
  <span class="hljs-comment">// Повертаємо результат виразу множення</span>
  <span class="hljs-keyword">return</span> product;
}
      
<span class="hljs-comment">// Результат роботи функції можна зберегти у змінну</span>
const result = multiply(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);
console.log(result); <span class="hljs-comment">// 30</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Щоб уникнути оголошення зайвої змінної в тілі функції, можна відразу ж
        <strong>повертати результат виразу</strong>. Так, немає необхідності
        створювати окрему змінну для зберігання результату виразу.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-gml"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">function</span> multiply(<span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>, z) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">x</span> * <span class="hljs-variable language_">y</span> * z;
}
      
const result = multiply(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);
console.log(result); <span class="hljs-comment">// 30</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Якщо в тілі функції відсутній оператор <code>return</code> або він не
        вказує на конкретне значення, функція поверне спеціальне значення
        <code>undefined</code>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-gml"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">function</span> multiply(<span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>, z) {
  const product = <span class="hljs-variable language_">x</span> * <span class="hljs-variable language_">y</span> * z;
}
      
const result = multiply(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);
console.log(result); <span class="hljs-comment">// undefined</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        При використанні оператора <code>return</code> всі інструкції, які йдуть
        на рядках після нього, в тілі функції не виконуються, оскільки виконання
        функції припиняється відразу після зустрічі оператора
        <code>return</code>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">x, y, z</span>) {
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">'The code before return is executed as usual'</span>);
      
  <span class="hljs-keyword">return</span> x * y * z;
      
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">'This code is never executed because it is after return'</span>);
}
      
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(multiply(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 30</span></pre>
        <button class="copy"></button>
      </div>

      <strong class="ql-size-large">Порядок виконання коду</strong>
      <p>
        Коли інтерпретатор зустрічає виклик функції, він зупиняє виконання
        поточного коду й починає виконувати код з тіла функції.
      </p>
      <p>
        Після того, як весь код у функції буде виконано, інтерпретатор повертає
        управління в те місце, звідки був здійснений виклик функції, і продовжує
        виконання коду програми, що залишився.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">x, y, z</span>) {
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`Result: <span class="hljs-subst">${x * y * z}</span>`</span>);
}
      
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Log before multiply execution"</span>);
multiply(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// "Result: 30"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Log after multiply execution"</span>);</pre>
        <button class="copy"></button>
      </div>
      <p>Послідовність логів у консолі буде такою:</p>
      <ol class="ol">
        <li>"Log before multiply execution"</li>
        <li>"Result: 30"</li>
        <li>"Log after multiply execution"</li>
      </ol>

      <strong class="ql-size-large">Область видимості функції</strong>
      <p>
        Область видимості визначає, де і які змінні та функції можуть бути
        доступні у твоєму коді. Коли ти оголошуєш змінну або функцію, вона стає
        "видимою" тільки в певній частині коду. Це впливає на те, де і як ти
        можеш використовувати їх у своєму коді.
      </p>
      <p>
        Змінні або функції, оголошені поза будь-якими блоками коду — тобто в
        глобальній області видимості, будуть доступні в будь-якій частині коду.
        Вони є <strong>глобальними змінними</strong>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-comment">// Глобальна змінна</span>
const value = <span class="hljs-string">"I'm a global variable"</span>;
        
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
<span class="hljs-comment">// Можна звернутися до глобальної змінної</span>
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value); <span class="hljs-comment">// "I'm a global variable"</span>
}
        
foo();
<span class="hljs-comment">// Можна звернутися до глобальної змінної</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value); 
<span class="hljs-comment">// "I'm a global variable"</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Змінна <code>value</code> оголошена в глобальній області видимості,
        тобто поза будь-яким блоком коду, у нашому випадку — поза тілом функції,
        і доступна в будь-якому місці після оголошення.
      </p>
      <p>
        Будь-яка конструкція, що використовує фігурні дужки
        <code>{}</code> (умови, цикли, функції тощо) створює нову
        <strong>локальну область видимості</strong>. Змінні, оголошені в
        локальній області видимості, можуть бути використані тільки всередині
        цього блоку коду.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Локальна змінна</span>
    const value = <span class="hljs-string">"I'm a local variable"</span>;
    <span class="hljs-comment">// Можна звернутися до локальної змінної</span>
    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value); <span class="hljs-comment">// "I'm a local variable"</span>
}
      
foo();
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value); <span class="hljs-comment">// ReferenceError: value is not defined</span>
                      <span class="hljs-comment">// Помилка: локальну змінну не видно за межами  </span> функції</pre>
        <button class="copy"></button>
      </div>
      <p>
        Змінна <code>value</code> оголошена в тілі функції <code>foo</code>,
        тобто в локальній області видимості функції, обмеженої тілом функції. Ця
        змінна буде доступна лише всередині функції, і спроба звернення до неї
        поза межами тіла функції видає помилку.
      </p>
    </section>

    <!--2. Модуль 2. Розгалуження і цикли-->
    <!--Розгалуження-->
    <section>
      <h2 id="branching">Розгалуження</h2>
      <p>
        Розгалуження — це конструкції, які дозволяють виконувати різні блоки
        коду залежно від певних умов. Це дозволяє програмі приймати рішення та
        виконувати різні дії в залежності від значень змінних або результатів
        обчислень.
      </p>
      <p>
        У JavaScript є кілька розгалужень, які дозволяють виконувати різні дії
        залежно від певних умов. Найпоширеніші з них:
      </p>
      <ul class="ul">
        <li><code>if</code>: виконує блок коду, якщо умова істинна.</li>
        <li><code>else</code>: виконує блок коду, якщо умова не істинна.</li>
        <li>
          <code>else if</code>: дозволяє перевірити додаткові умови, якщо
          попередня умова не істинна.
        </li>
        <li>
          <code>switch</code>: дозволяє виконувати різні блоки коду залежно від
          значення виразу.
        </li>
        <li>
          <code>ternary operator</code>: коротка форма для умовного
          розгалуження, яка дозволяє виконати одну з двох дій залежно від
          істинності умови.
        </li>
      </ul>
      <p>
        <strong class="ql-size-large">Інструкція </strong
        ><code class="ql-size-large"><strong>if</strong></code>
      </p>
      <p>
        Інструкція <code>if</code> дозволяє виконати певний блок коду
        <strong>тільки</strong> в тому випадку, <strong>якщо</strong> задана
        <strong>умова істинна</strong> (тобто приймає значення
        <code><strong>true</strong></code
        >).
      </p>
      <p>
        Загальний синтаксис інструкції <code><strong>if</strong></code> виглядає
        так:
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-mel"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">if</span> (<span class="hljs-keyword">condition</span>) {
  <span class="hljs-comment">// код, який виконується, якщо умова (condition) істинна</span>
}</pre>
        <button class="copy"></button>
      </div>
      <p>
        Коли інтерпретатор зустрічає інструкцію <code>if</code>, він
        <strong>обчислює вказану умову в круглих дужках</strong>
        <strong>(condition</strong>), перетворюючи її до логічного типу
        (boolean).
      </p>
      <p>
        Якщо умова (condition) перетворюється до <code>true</code>,
        <strong>виконується блок коду, написаний у фігурних дужках </strong
        ><code><strong>{}</strong></code
        ><strong> — (statement)</strong>.
      </p>
      <p>
        Якщо умова (condition) перетворюється до <code>false</code>, блок коду
        не виконається і продовжиться виконання програми, що іде після
        інструкції <code>if</code>.
      </p>
      <img
        src="../js/images/39722949-7466-43b5-b90e-6b6723588545Frame 48583 (1).jpg"
        alt=""
      />
      <p>
        У наведених нижче прикладах код перевіряє значення змінної
        <code>subscription</code> і залежно від нього встановлює значення
        змінної <code>price</code>.
      </p>
      <p>
        Якщо умова перетворюється до <code>true</code>, тобто
        <code>subscription</code> — це <code>"pro"</code>,
        <code>price</code> встановлюється <code>100</code>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >let price <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span>
const subscription <span class="hljs-operator">=</span> <span class="hljs-string">"pro"</span><span class="hljs-comment">;</span>

if (subscription <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">"pro"</span>) {
  price <span class="hljs-operator">=</span> <span class="hljs-number">100</span><span class="hljs-comment">;</span>
}

console.log(price)<span class="hljs-comment">; // 100</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Якщо умова перетворюється до <code>false</code>, код у фігурних дужках
        не буде виконуватися і <code>price</code> залишиться рівним
        <code>0</code>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >let price <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span>
const subscription <span class="hljs-operator">=</span> <span class="hljs-string">"free"</span><span class="hljs-comment">;</span>

if (subscription <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">"pro"</span>) {
  price <span class="hljs-operator">=</span> <span class="hljs-number">100</span><span class="hljs-comment">;</span>
}

console.log(price)<span class="hljs-comment">; // 0</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Напишемо функцію яка отримує обраний тарифний план у параметрі
        <code>subscription</code> та повертає його вартість.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >function getPrice(subscription) {
  let price <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span>
	
  if (subscription <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">"pro"</span>) {
	price <span class="hljs-operator">=</span> <span class="hljs-number">100</span><span class="hljs-comment">;</span>
  }
	
  return price<span class="hljs-comment">;</span>
}

console.log(getPrice(<span class="hljs-string">"free"</span>))<span class="hljs-comment">; // 0	</span>
console.log(getPrice(<span class="hljs-string">"pro"</span>))<span class="hljs-comment">; // 100	</span></pre>
        <button class="copy"></button>
      </div>
      <p>Функція <code>getPrice</code> працює так:</p>
      <p>
        <strong>1) Приймає параметр</strong> <code>subscription</code> – рядок,
        який вказує тип підписки (наприклад, <code>"pro"</code> або
        <code>"free"</code>).
      </p>
      <p>
        <strong>2) Оголошує змінну</strong> <code>price</code> і встановлює її
        значення в <code>0</code> за замовчуванням.
      </p>
      <p><strong>3) Перевіряє умову</strong>:</p>
      <ul class="ul">
        <li>
          Якщо <code>subscription === "pro"</code>, то змінній
          <code>price</code> присвоюється значення <code>100</code>.
        </li>
        <li>
          Якщо <code>subscription</code> не <code>"pro"</code>, нічого не
          змінюється, і <code>price</code> залишається <code>0</code>.
        </li>
      </ul>
      <p>
        <strong>4) Повертає значення </strong
        ><code><strong>price</strong></code> після перевірки.
      </p>
      <p><strong>Покрокове виконання:</strong></p>
      <p>Виклик <code>getSubscriptionPrice("free")</code>:</p>
      <ul class="ul">
        <li><code>subscription = "free"</code></li>
        <li><code>price = 0</code> (початкове значення)</li>
        <li>
          <code>if (subscription === "pro")</code> → <strong>false</strong>,
          тому код всередині <code>if</code> не виконується.
        </li>
        <li><code>return price</code> → повертається <code>0</code>.</li>
      </ul>
      <p>Виклик <code>getSubscriptionPrice("pro")</code>:</p>
      <ul class="ul">
        <li><code>subscription = "pro"</code></li>
        <li><code>price = 0</code> (початкове значення)</li>
        <li>
          <code>if (subscription === "pro")</code> → <strong>true</strong>, тому
          <code>price = 100</code>.
        </li>
        <li><code>return price</code> → повертається <code>100</code>.</li>
      </ul>

      <p>
        <strong class="ql-size-large">Інструкція </strong
        ><code class="ql-size-large"><strong>if...else</strong></code>
      </p>
      <p>
        Синтаксис інструкції <code>if</code> можна доповнити блоком
        <code>else</code> для визначення альтернативних варіантів виконання
        коду.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-mel"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">if</span> (<span class="hljs-keyword">condition</span>) {
  <span class="hljs-comment">// код, який виконується, якщо умова істинна</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// код, який виконується, якщо умова хибна</span>
}</pre>
        <button class="copy"></button>
      </div>
      <p>
        Якщо умова (condition) перетворюється до <code>true</code>, то
        виконається код блоку <code>if</code> (if block statements).
      </p>
      <p>
        Якщо умова (condition) перетворюється до <code>false</code>, то
        виконається код блоку <code>else</code> (else block statements).
      </p>
      <img
        src="../js/images/3b1ab92c-b3b9-45f4-9c0e-bc371015eaccFrame 48584.jpg"
        alt=""
      />
      <p>
        У наступному прикладі умова перетворюється до <code>true</code>, тому
        виконується код у тілі (фігурних дужках) блоку <code>if</code>, а тіло
        блоку <code>else</code> ігнорується.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >const grade <span class="hljs-operator">=</span> <span class="hljs-number">85</span><span class="hljs-comment">;</span>

if (grade &gt;<span class="hljs-operator">=</span> <span class="hljs-number">70</span>) {
  console.log(<span class="hljs-string">"Satisfactory"</span>)<span class="hljs-comment">;</span>
} else {
  console.log(<span class="hljs-string">"Unsatisfactory"</span>)<span class="hljs-comment">;</span>
}</pre>
        <button class="copy"></button>
      </div>
      <p>
        Якщо умова перетворюється до <code>false</code>, код із тіла блоку
        <code>if</code> буде пропущений, і виконається код із тіла блоку
        <code>else</code>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >const grade <span class="hljs-operator">=</span> <span class="hljs-number">40</span><span class="hljs-comment">;</span>

if (grade &gt;<span class="hljs-operator">=</span> <span class="hljs-number">70</span>) {
  console.log(<span class="hljs-string">"Satisfactory"</span>)<span class="hljs-comment">;</span>
} else {
  console.log(<span class="hljs-string">"Unsatisfactory"</span>)<span class="hljs-comment">;</span>
}</pre>
        <button class="copy"></button>
      </div>
      <p>
        Створимо функцію яка отримує бал студента, та повертає рішення про
        результат.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkGrade</span>(<span class="hljs-params">grade</span>) {
  <span class="hljs-keyword">if</span> (grade &gt;= <span class="hljs-number">70</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Satisfactory"</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Unsatisfactory"</span>;
  }
}

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(checkGrade(<span class="hljs-number">40</span>)); <span class="hljs-comment">// Unsatisfactory</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(checkGrade(<span class="hljs-number">75</span>)); <span class="hljs-comment">// Satisfactory</span></pre>
        <button class="copy"></button>
      </div>
      <p>Функція <code>checkGrade</code> працює так:</p>
      <p>
        1) Вона приймає один параметр – <code>grade</code>, який містить числове
        значення (оцінку студента).
      </p>
      <p>
        2) Використовує <code>if...else</code>, щоб перевірити, чи
        <code>grade</code> <strong>більше або дорівнює 70</strong>:
      </p>
      <ul class="ul">
        <li>
          Якщо <strong>true</strong>, повертає <code>"Satisfactory"</code>.
        </li>
        <li>
          Якщо <strong>false</strong>, повертає <code>"Unsatisfactory"</code>.
        </li>
      </ul>
      <p>3) Виклик <code>console.log(checkGrade(40))</code>:</p>
      <ul class="ul">
        <li>
          Оскільки <code>40 &lt; 70</code>, виконується <code>else</code>, тому
          повертається <code>"Unsatisfactory"</code>.
        </li>
      </ul>
      <p>4) Виклик <code>console.log(checkGrade(75))</code>:</p>
      <ul class="ul">
        <li>
          Оскільки <code>75 &gt;= 70</code>, виконується <code>if</code>, тому
          повертається <code>"Satisfactory"</code>.
        </li>
      </ul>
      <p><strong>Приклад покрокового виконання:</strong></p>
      <p>Для виклику <code>checkGrade(40)</code> :</p>
      <ul class="ul">
        <li><code>grade = 40</code></li>
        <li><code>40 &gt;= 70</code> → <strong>false</strong></li>
        <li>Виконується <code>else</code></li>
        <li>Повертає <code>"Unsatisfactory"</code></li>
      </ul>
      <p>Для виклику <code>checkGrade(75)</code> :</p>
      <ul class="ul">
        <li><code>grade = 75</code></li>
        <li><code>75 &gt;= 70</code> → <strong>true</strong></li>
        <li>Виконується <code>if</code></li>
        <li>Повертає <code>"Satisfactory"</code></li>
      </ul>

      <strong class="ql-size-large">Блок&nbsp;else...if</strong>
      <p>
        Конструкція <code>else...if</code> розширює конструкцію
        <code>if...else</code> і дозволяє перевірити та зреагувати на виконання
        або невиконання кількох умов. Це корисно, коли ми маємо більше однієї
        умови.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-aspectj"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">if</span> (condition_1) {
  <span class="hljs-comment">// код, який виконується, якщо умова (condition_1) істинна</span>
} <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(condition_2)</span> </span>{
  <span class="hljs-comment">// код, який виконується, якщо умова (condition_2) істинна</span>
} <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(condition_3)</span> </span>{
  <span class="hljs-comment">// код, який виконується, якщо умова (condition_3) істинна</span>
} <span class="hljs-keyword">else</span> {
	<span class="hljs-comment">// код, який виконується, якщо всі умови хибні</span>
}</pre>
        <button class="copy"></button>
      </div>
      <p>Кожна умова послідовно перевіряється зверху вниз.</p>
      <p>
        Якщо умова <code>condition_1</code> <strong>істинна</strong>,
        виконується відповідний блок коду, і перевірка завершується.
      </p>
      <p>
        Якщо умова <code>condition_1</code> <strong>хибна</strong>, то
        перевіряється умова_2 і далі.
      </p>
      <p>
        Код у блоці <code>else</code> буде виконаний тільки у випадку, якщо
        <strong>жодна з умов</strong> у блоках <code>if</code> та
        <code>else</code> <code>if</code> не є істинною.
      </p>
      <p>
        Перевірка зупиняється, щойно програма знаходить першу умову, яка
        задовільняється. При цьому виконується тільки тіло відповідного блоку
        <code>if</code> або <code>else if</code>. Тому ланцюжок умов слід читати
        як: «Шукаю першу умову, що виконується, та ігнорую все інше».
      </p>
      <p>Візуально це можна представити на схемі нижче:</p>
      <img
        src="../js/images/9f84cdd9-ab89-4ac2-b1f8-d9965b7e03abFrame 48585 (1).jpg"
        alt=""
      />
      <p>
        У цьому прикладі спочатку перевіряється умова
        <code>grade &gt;= 90</code>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        >const grade = <span class="hljs-number">85</span>;

<span class="hljs-keyword">if</span> (grade &gt;= <span class="hljs-number">90</span>) {
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Perfectly"</span>);
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grade &gt;= <span class="hljs-number">80</span>) {
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Good"</span>);
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grade &gt;= <span class="hljs-number">70</span>) {
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Satisfactorily"</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Unsatisfactorily"</span>);
}</pre>
        <button class="copy"></button>
      </div>
      <p>
        Оскільки перша умова (<code>grade &gt;=</code> <code>90</code>)
        помилкова, то тіло <code>if</code> не виконується і перевіряється
        наступна умова (<code>grade &gt;= 80</code>). Ця умова є істинною, тому
        виконується тіло <code>else if</code>, тобто
        <code>console.log("Good")</code>. Подальші умови вже перевірятись не
        будуть.
      </p>

      <strong class="ql-size-large">Тернарний оператор</strong>
      <p>
        Тернарний оператор — це коротша синтаксична заміна інструкції
        <code>if...else</code>. Тернарний оператор дозволяє виконувати певну
        частину коду залежно від умови.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-ada"
          spellcheck="false"
          data-highlighted="yes"
        >&lt;condition&gt; ? &lt;expression <span class="hljs-keyword">if</span> condition <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span>&gt; : &lt;<span class="hljs-type">expression</span> <span class="hljs-keyword">if</span> condition <span class="hljs-keyword">is</span> <span class="hljs-literal">false</span>&gt;</pre>
        <button class="copy"></button>
      </div>
      <p>Він працює таким чином:</p>
      <ul class="ul">
        <li>обчислюється умова <code>condition</code>;</li>
        <li>
          якщо умова істинна (перетворюється до <code>true</code>), обчислюється
          вираз після <code>?</code>;
        </li>
        <li>
          якщо умова хибна (перетворюється до <code>false</code>), обчислюється
          вираз після <code>:</code>;
        </li>
        <li>
          значення обчисленого виразу повертається як результат роботи
          тернарного оператора.
        </li>
      </ul>
      <p>
        Завдяки тому, що тернарний оператор повертає значення обчисленого виразу
        , його можна застосовувати для задавання різних значень для однієї
        змінної залежно від умови. Ось приклад, як би це виглядало з
        використанням інструкції <code>if...else</code>
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-typescript"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">let</span> <span class="hljs-keyword">type</span>;
<span class="hljs-keyword">const</span> age = <span class="hljs-number">20</span>;

<span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>) {
  <span class="hljs-keyword">type</span> = <span class="hljs-string">'adult'</span>;
} <span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">type</span> = <span class="hljs-string">'child'</span>;
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">type</span>); <span class="hljs-comment">// 'adult'</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Той самий код можна переписати з використанням тернарного оператора:
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-typescript"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">const</span> age = <span class="hljs-number">20</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">type</span> = age &gt;= <span class="hljs-number">18</span> ? <span class="hljs-string">'adult'</span> : <span class="hljs-string">'child'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">type</span>); <span class="hljs-comment">// 'adult'</span></pre>
        <button class="copy"></button>
      </div>
      <p>
        Другий приклад: знаходження більшого числа із двох з використанням
        інструкції <code>if...else</code>:
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-abnf"
          spellcheck="false"
          data-highlighted="yes"
        >const a <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-comment">;</span>
const b <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;</span>
let biggerNumber<span class="hljs-comment">;</span>

if (a &gt; b) {
  biggerNumber <span class="hljs-operator">=</span> a<span class="hljs-comment">;</span>
} else {
  biggerNumber <span class="hljs-operator">=</span> b<span class="hljs-comment">;</span>
}

console.log(biggerNumber)<span class="hljs-comment">; // 10</span></pre>
        <button class="copy"></button>
      </div>
      <p>Використовуючи тернарний оператор, код вище можна спростити:</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-cpp"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-type">const</span> a = <span class="hljs-number">5</span>;
<span class="hljs-type">const</span> b = <span class="hljs-number">10</span>;
<span class="hljs-type">const</span> biggerNumber = a &gt; b ? a : b;

console.<span class="hljs-built_in">log</span>(biggerNumber); <span class="hljs-comment">// 10</span></pre>
        <button class="copy"></button>
      </div>
      <pre
        class="ql-blockquote"
        spellcheck="false"
      >Тернарний оператор рекомендується<strong> використовувати у найпростіших випадках операції присвоєння чи повернення</strong>. 
Однак <strong>не рекомендується</strong> використовувати його <strong>для складних розгалужень</strong>, оскільки це може ускладнити читання та розуміння коду.
</pre>
      <p>Ось приклад з фукнцією яка порівнює два числа.</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">function</span> <span class="hljs-title function_">getBiggerNumber</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a &gt; b ? a : b;
}

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(getBiggerNumber(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">// 10</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(getBiggerNumber(<span class="hljs-number">20</span>, <span class="hljs-number">15</span>)); <span class="hljs-comment">// 20</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(getBiggerNumber(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>)); <span class="hljs-comment">// 7</span></pre>
        <button class="copy"></button>
      </div>
      <p>Як працює ця функція:</p>
      <p>
        <strong>1) Приймає два параметри</strong> – <code>a</code> і
        <code>b</code>.
      </p>
      <p>
        <strong>2) Використовує тернарний оператор (</strong
        ><code><strong>? :</strong></code
        ><strong>)</strong>, який працює так:
      </p>
      <ul class="ul">
        <li><strong>Умова:</strong> <code>a &gt; b</code></li>
        <li>Якщо <strong>true</strong> → повертає <code>a</code></li>
        <li>Якщо <strong>false</strong> → повертає <code>b</code></li>
      </ul>
      <p><strong>3) Повертає більший із двох чисел</strong>.</p>
      <p>Покрокове виконання:</p>
      <ul class="ul">
        <li>
          Виклик <code>getBiggerNumber(5, 10)</code>: <code>5 &gt; 10</code> →
          <strong>false</strong>, повертається <code>b = 10</code>.
        </li>
        <li>
          Виклик <code>getBiggerNumber(20, 15)</code>: <code>20 &gt; 15</code> →
          <strong>true</strong>, повертається <code>a = 20</code>.
        </li>
        <li>
          Виклик <code>getBiggerNumber(7, 7)</code>: <code>7 &gt; 7</code> →
          <strong>false</strong>, повертається <code>b = 7</code> (немає
          різниці, що повертати, бо числа рівні).
        </li>
      </ul>
      <p>
        <strong class="ql-size-large">Оператор </strong
        ><code class="ql-size-large"><strong>switch</strong></code>
      </p>
      <p>
        Оператор <code>switch</code> дозволяє виконувати різні дії залежно від
        значення виразу. Використання <code>switch</code> є більш компактним і
        зручним способом для порівняння виразів з кількома варіантами, ніж
        інструкції <code>if...else</code> та <code>else...if</code>.
      </p>
      <p>Ось загальний синтаксис оператора <code>switch</code>:</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-mel"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">switch</span> (<span class="hljs-keyword">expression</span>) {
  <span class="hljs-keyword">case</span> value1:
    <span class="hljs-comment">// код, що виконується, якщо вираз (expression) дорівнює value1</span>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> value2:
    <span class="hljs-comment">// код, що виконується, якщо вираз (expression) дорівнює value2</span>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">default</span>:
    <span class="hljs-comment">// код, що виконується, якщо вираз (expression) не відповідає жодному значенню</span>
}</pre>
        <button class="copy"></button>
      </div>
      <p>Як це працює:</p>
      <ol class="ol">
        <li>
          Вираз (expression) в операторі <code>switch</code> обчислюється.
        </li>
        <li>
          Значення виразу порівнюється з кожним блоком <code>case</code> зверху
          вниз.
        </li>
        <li>
          Якщо значення виразу відповідає значенню в блоці <code>case</code>,
          виконується код цього блоку.
        </li>
        <li>
          Коли виконання коду блоку <code>case</code> завершено, необхідно
          використовувати оператор <code>break</code>, щоб вийти зі
          <code>switch</code>. Це запобігає виконанню коду в наступних блоках
          <code>case</code>.
        </li>
        <li>
          Якщо жодне значення не відповідає виразу, виконається код у блоці
          <code>default</code> (якщо він є).
        </li>
      </ol>
      <pre class="ql-blockquote" spellcheck="false">
За наявності блоку default його слід розташовувати останнім у блоці коду з оператором switch.</pre
      >
      <img
        src="../js/images/8b769e23-832a-429a-ad7c-4d27659206e2Frame 48586.jpg"
        alt=""
      />
      <p>Приклад використання оператора <code>switch</code>:</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        >const fruit = <span class="hljs-string">'apple'</span>;

<span class="hljs-keyword">switch</span> (fruit) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">'apple'</span>:
    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">'Apple selected'</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-string">'banana'</span>:
    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">'Banana selected'</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-string">'orange'</span>:
    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">'Orange selected'</span>);
    <span class="hljs-keyword">break</span>;
  default:
    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">'The fruit is unknown'</span>);
}</pre>
        <button class="copy"></button>
      </div>
      <p>
        У цьому прикладі виразом є значення змінної <code>fruit</code>, яке
        порівнюється з різними значеннями блоків <code>case</code>. Якщо
        значення <code>fruit</code> відповідає одному з них, буде виведено
        відповідне повідомлення. Якщо жоден блок <code>case</code> не підійде,
        буде виконано код у блоці <code>default</code>.
      </p>
      <ul class="ul">
        <li>
          Із прикладу видно, що застосування&nbsp;<code>switch</code> обмежене
          завданнями з одним загальним питанням (що порівнювати) та безліччю
          варіантів відповідей (з чим порівнювати).
        </li>
        <li>
          Вираз у блоці&nbsp;<code>switch</code> — вираз будь-якого типу (змінна
          чи складні обчислення), результат якого послідовно зверху вниз, суворо
          порівнюється (<code>===</code>) з усіма значеннями в
          блоках&nbsp;<code>case</code>. Тобто не можна порівняти на більше чи
          менше, лише на сувору рівність.
        </li>
        <li>
          Оператор <code>break</code> додається наприкінці кожного блоку
          <code>case</code>. Функція оператора <code>break</code> — перервати
          подальші перевірки й відразу перейти до коду, що йде після
          <code>switch</code>, щойно виконався якийсь із блоків
          <code>case</code>.
        </li>
        <li>
          Якщо жодного збігу значень не відбулося, необхідно виконати код за
          замовчуванням. Для цього в кінці після всіх блоків
          <code>case</code> додається блок <code>default</code>.
        </li>
        <li>
          Оператор <code>break</code> після блоку <code>default</code> не
          потрібен, тому що це і так останнє, що буде виконано у
          <code>switch</code> і управління буде передано коду за ним.
        </li>
      </ul>
      <p>
        <strong class="ql-size-large">Оператор </strong
        ><code class="ql-size-large"><strong>break</strong></code>
      </p>
      <p>
        Після виконання коду в одному з випадків потрібно використовувати
        оператор <code>break</code>, щоб вийти з оператора <code>switch</code>.
      </p>
      <p>
        Якщо <code>break</code> не вказано, виконання коду продовжиться в
        наступному <code>case</code> і далі. Така поведінка називається
        "провалюванням" (fall-through). Якщо потрібно, щоб кілька блоків
        <code>case</code> виконували той самий код, можна опустити оператор
        <code>break</code> між ними.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        >const <span class="hljs-built_in">day</span> = <span class="hljs-number">3</span>;

<span class="hljs-keyword">switch</span> (<span class="hljs-built_in">day</span>) {
  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">'This is a working day'</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:
    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">'It is a day off'</span>);
    <span class="hljs-keyword">break</span>;
  default:
    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">'Invalid'</span>);
}</pre>
        <button class="copy"></button>
      </div>
      <p>
        У цьому прикладі кілька блоків (<code>case 1</code>,
        <code>case 2</code>, <code>case 3</code>, <code>case 4</code>,
        <code>case 5</code>) провалюються і у випадку їх рівності виразу
        виконається один і той самий код, тому що між ними немає операторів
        <code>break</code>.
      </p>
      <div class="ql-editor">
        <p>
          <strong class="ql-size-large"
            >Пам’ятка під час використання розгалужень</strong
          >
        </p>
        <p>
          Наразі тобі знайомі кілька способів, як зробити розгалуження. Під час
          вибору слід пам’ятати:
        </p>
        <ul class="ul">
          <li>
            <strong>Інструкція</strong> <code>if</code> є універсальною.
            Інструкції <code>if…else</code> і
            <code>else…if</code> використовуються, коли потрібно прописати
            декілька умов. Отже, ці інструкції зазвичай довші, ніж інші способи
            розгалужень.
          </li>
          <li>
            <strong>Тернарний оператор</strong> краще використовувати для
            присвоєння або повернення значення з тіла функції. В умові
            тернарного оператора може бути все що завгодно: перевірка рівності /
            нерівності, на більше / менше, просто перевірка на будь чого.
          </li>
        </ul>
        <pre class="ql-blockquote" spellcheck="false">
Пам’ятай про обмеження: у нього має бути рівно 2 сценарії, не більше.</pre
        >
        <ul>
          <li>
            <strong>Оператор</strong> <code>switch</code> перевіряє тільки на
            сувору рівність.
          </li>
        </ul>
        <pre class="ql-blockquote" spellcheck="false">
Використовуючи оператор <code>switch</code>, завжди: 
— пам’ятай про оператор break;
— використовуй тільки 1 default, він завжди має бути останнім.</pre
        >
      </div>

      <strong class="ql-size-large">Блокова область видимості</strong>
      <p>
        У JavaScript блокова область видимості визначає, де змінні можуть бути
        доступні. Змінні, оголошені в блоці (наприклад, у фігурних дужках
        <code>{}</code>), доступні лише всередині цього блоку.
      </p>
      <p>
        Область видимості визначає, чи будуть змінні та функції доступними в
        певних областях коду. Під час оголошення змінної або функції, вона стає
        "видимою" тільки в певній частині коду. Це впливає на те, де і як можна
        використовувати ці змінні та функції в коді.
      </p>
      <p>
        Змінні або функції, які оголошені поза будь-якими блоками коду — тобто в
        глобальній області видимості — будуть доступні в будь-якій частині коду.
        Вони є <strong>глобальними змінними</strong>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-comment">// Глобальна змінна</span>
const value = <span class="hljs-string">"I'm a global variable"</span>;

<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
	<span class="hljs-comment">// Можна звернутися до глобальної змінної</span>
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value); <span class="hljs-comment">// "I'm a global variable"</span>
}

<span class="hljs-comment">// Можна звернутися до глобальної змінної</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value); <span class="hljs-comment">// "I'm a global variable"</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>
        Змінна <code>value</code> оголошена в глобальній області видимості,
        тобто поза будь-яким блоком коду, у нашому випадку поза тілом інструкції
        <code>if</code>. Вона буде доступна в будь-якому місці після оголошення.
      </p>
      <p>
        Будь-яка конструкція, що використовує фігурні дужки
        <code>{}</code> (умови, функції, цикли тощо) створює нову локальну
        блочну область видимості. Змінні, оголошені в цій області видимості,
        можуть бути використані тільки всередині цього блоку коду. Це
        <strong>локальні змінні</strong>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-comment">// Локальна змінна</span>
	const value = <span class="hljs-string">"I'm a local variable"</span>;
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value); <span class="hljs-comment">// "I'm a local variable"</span>
}

<span class="hljs-comment">// Помилка: локальну змінну не видно за межами блоку</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value); <span class="hljs-comment">// ReferenceError: value is not defined</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>
        Змінна&nbsp;<code>value</code>&nbsp;оголошена в тілі інструкції
        <code>if</code>, тобто в локальній області видимості, обмеженій тілом
        блоку <code>if</code>. Ця змінна буде доступна лише всередині блоку
        <code>if</code>, і спроба звернення до неї поза блоком
        <code>if</code> викликає помилку.
      </p>
      <p>Розберемо приклад вкладених областей видимості на ілюстрації.</p>
      <p>
        Є глобальна область видимості, називатимемо її <code>Global</code>.
        Також існують три блокові області видимості <code>A</code>,
        <code>B</code> і <code>C</code>, що утворені, наприклад, інструкціями
        <code>if</code>.
      </p>
      <img
        src="../js/images/1a13655a-f84e-4561-b73b-19e0fde08a7dFrame 48587 (1).jpg"
        alt=""
      />
      <p>
        Змінні, оголошені в глобальній області видимості, доступні в усіх
        вкладених областях видимості. Тобто змінна <code>Global</code> буде
        доступна в областях <code>A</code>, <code>B</code> і <code>C</code>.
      </p>
      <p>
        Глибина вкладеності областей видимості не обмежена, і всі вони працюють
        за певним принципом.
      </p>
      <p>
        Область видимості <strong>має доступ</strong> до змінних, що оголошені:
      </p>
      <ol class="ol">
        <li>у цій області видимості;</li>
        <li>у вищій за ієрархією області видимості.</li>
      </ol>
      <p>
        Область видимості <strong>не має доступу</strong> до змінних, що
        оголошені у вкладених областях видимості.
      </p>
      <ul class="ul">
        <li>
          Код у блоці <code>A</code> має доступ до змінних, оголошених у
          <code>Global</code>, але не має доступу до змінних, оголошених у
          блоках <code>B</code> і <code>C</code>.
        </li>
        <li>
          Код у блоці <code>B</code> має доступ до змінних, оголошених у
          <code>Global</code> і в блоці <code>A</code>, але не має доступу до
          змінних, оголошених у блоці <code><strong>C</strong></code
          >.
        </li>
        <li>
          Код у блоці <code>C</code> має доступ до змінних, оголошених у
          <code>Global</code>, але не має доступу до змінних, оголошених у
          блоках <code>A</code> і <code>B</code>.
        </li>
      </ul>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        >const globalVar = <span class="hljs-string">"Global"</span>;

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(globalVar); <span class="hljs-comment">// Доступ до globalVar з глобальної області видимості</span>
<span class="hljs-comment">// Немає доступу до aVar, bVar і cVar</span>

<span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) {
	const aVar = <span class="hljs-string">"A"</span>;
	<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(globalVar); <span class="hljs-comment">// Доступ до globalVariable з блоку A</span>
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(aVar); <span class="hljs-comment">// Доступ до aVar з блоку A</span>
	<span class="hljs-comment">// Немає доступу до bVar і cVar</span>

	<span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) {
		const bVar = <span class="hljs-string">"B"</span>;
		<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(globalVar); <span class="hljs-comment">// Доступ до globalVariable з блоку B</span>
	  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(aVar); <span class="hljs-comment">// Доступ до aVar з блоку B</span>
	  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(bVar); <span class="hljs-comment">// Доступ до bVar з блоку B</span>
		<span class="hljs-comment">// Немає доступу до cVar</span>
	}
}

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(globalVar); <span class="hljs-comment">// Доступ до globalVar із глобальної області видимості</span>
<span class="hljs-comment">// Немає доступу до aVar, bVar і cVar</span>

<span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) {
	const cVar = <span class="hljs-string">"C"</span>;
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(globalVariable); <span class="hljs-comment">// Доступ до globalVar з блоку C</span>
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(cVar); <span class="hljs-comment">// Доступ до cVar з блоку C</span>
	<span class="hljs-comment">// Немає доступу до aVar і bVar</span>
}

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(globalVar); <span class="hljs-comment">// Доступ до globalVar із глобальної області видимості</span>
<span class="hljs-comment">// Немає доступу до aVar, bVar і cVar</span>
</pre>
        <button class="copy"></button>
      </div>
    </section>
    <!--Логічні оператори-->
    <section>
      <h2 id="logical-operators">Логічні оператори</h2>
      <strong class="ql-size-large">Перетворення типів: логічне</strong>
      <p>
        Логічне перетворення типів означає приведення значення будь-якого типу
        даних у логічне (булеве) значення <code>true</code> або
        <code>false</code>. Існує кілька правил, які визначають, які значення
        перетворюються на <code>true</code>, а які на <code>false</code>.
      </p>
      <p>Ці правила працюють:</p>
      <ul class="ul">
        <li>
          як для <strong>явного </strong>перетворення типів за допомогою функції
          <code>Boolean()</code>,
        </li>
        <li>
          так і для <strong>неявного</strong> в умовних операціях, наприклад, у
          конструкціях <code>if</code> чи логічних операторах.
        </li>
      </ul>
      <p><strong>Логічні значення</strong></p>
      <p>
        Логічні значення <code>true</code> та <code>false</code> залишаються
        незмінними.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>)); <span class="hljs-comment">// false</span>
</pre>
        <button class="copy"></button>
      </div>
      <p><strong>Числа</strong></p>
      <p>
        Число <code>0</code>, значення <code>NaN</code>, <code>null</code> і
        <code>undefined</code> завжди перетворюються на <code>false</code>. Усі
        інші числа перетворюються на <code>true</code>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">3.14</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">-10</span>)); <span class="hljs-comment">// true</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>Розгляньмо ці приклади.</p>
      <p>Який блок коду буде виконуватися?</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-stylus"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(null)</span></span> {
	console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"Block if"</span>)
} <span class="hljs-keyword">else</span> {
	console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"Block else"</span>)
}

<span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> {
	console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"Block if"</span>)
} <span class="hljs-keyword">else</span> {
	console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"Block else"</span>)
}
</pre>
        <button class="copy"></button>
      </div>
      <p>
        Значення в умові інструкцій <code>if</code> приводиться до
        <code>false</code> .
      </p>
      <p>Отже, виконується код із блоку <code>else</code>.</p>
      <p>А в цьому прикладі який код виконується?</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-stylus"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span> {
	console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"Block if"</span>)
} <span class="hljs-keyword">else</span> {
	console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"Block else"</span>)
}
</pre>
        <button class="copy"></button>
      </div>
      <p>
        Значення в умові інструкції <code>if</code> приводиться до
        <code>true</code> .
      </p>
      <p>Отже, виконується код із блоку <code>if</code>.</p>

      <p><strong>Рядки</strong></p>
      <p>
        Порожній рядок (<code>""</code>) приводиться до <code>false</code>.
        Будь-які інші не пусті рядки приводяться до <code>true</code>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">""</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">"hello"</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">"false"</span>)); <span class="hljs-comment">// true</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>Прочитай приклад нижче.</p>
      <p>Код із якого блоку буде виконано?</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-stylus"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(<span class="hljs-string">""</span>)</span></span> {
	console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"Block if"</span>)
} <span class="hljs-keyword">else</span> {
	console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"Block else"</span>)
}
</pre>
        <button class="copy"></button>
      </div>
      <p>
        У прикладі в умові інструкції <code>if</code> вказаний порожній рядок.
      </p>
      <p>
        Порожній рядок приводиться до <code>false</code>. Отже, виконується код
        із блоку <code>else</code>.
      </p>
      <p>А в цьому прикладі?</p>
      <p>Який саме блок коду буде виконано?</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-stylus"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(<span class="hljs-string">"batman"</span>)</span></span> {
	console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"Block if"</span>)
} <span class="hljs-keyword">else</span> {
	console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"Block else"</span>)
}
</pre>
        <button class="copy"></button>
      </div>
      <p>В умові інструкції — рядок <code>"batman"</code>.</p>
      <p>
        Отже, <code>if</code> наводиться до <code>true</code>. Виконується код
        із блоку <code>if</code>.
      </p>
      <pre
        class="ql-blockquote"
        spellcheck="false"
      >Запам’ятай <strong>6 випадків</strong>, які <strong>приводяться до false</strong>:
    1. 0
    2. ""
    3. Nan
    4. null
    5. undefined
    6. false
</pre>

      <strong class="ql-size-large">Логічне «І»</strong>
      <p>
        Логічні оператори використовуються для перевірки умов з кількома
        виразами, наприклад, в інструкції <code>if</code>.
      </p>
      <p>
        Оператор "І" (<code>&amp;&amp;</code>) наводить усі операнди до
        логічного типу (<code>true</code> або <code>false</code>) і повертає
        значення одного з них. Дозволяє перевірити, чи виконані
        <strong>всі умови</strong> у виразі.
      </p>
      <img
        src="../js/images/765fba89-6cda-41e6-921b-55d6f48aeb7eFrame 771431.jpg"
        alt=""
      />
      <p>Обчислення оператора відбувається зліва направо.</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-1c"
          spellcheck="false"
          data-highlighted="yes"
        >expression1 <span class="hljs-meta">&amp;&amp; expression2</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>
        Оператор “І” зліва направо перевіряє почергово обидва операнди на
        істинність та повертає або значення останнього істинного (тільки
        правого) операнда, або першого хибного (лівого чи правого), на якому він
        запнувся.
      </p>
      <p>
        Давай розглянемо це на простому прикладі. Уяви: якщо людина п’є каву з
        цукром і молоком, то її не влаштує кава хоча б без одного з цих
        компонентів. Усі компоненти є обов’язковими, інакше людина її пити не
        буде.
      </p>
      <p>
        У наступних прикладах обидва операнди перетворюються на
        <code>true</code>. Обчислення відбуваються зліва направо, тому
        результатом буде значення правого операнда.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"hello"</span> &amp;&amp; <span class="hljs-number">5</span>); <span class="hljs-comment">// 5</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> &amp;&amp; <span class="hljs-string">"hello"</span>); <span class="hljs-comment">// "hello"</span>

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"mango"</span> &amp;&amp; <span class="hljs-string">"poly"</span>); <span class="hljs-comment">// "poly"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"poly"</span> &amp;&amp; <span class="hljs-string">"mango"</span>); <span class="hljs-comment">// "mango"</span>

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span> &amp;&amp; <span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-number">3</span>); <span class="hljs-comment">// 3</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>
        А ось у цьому прикладі один із операндів буде приведений до
        <code>false</code>, отже, результатом буде хибний операнд.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"hello"</span> &amp;&amp; <span class="hljs-number">0</span>); <span class="hljs-comment">// 0</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-string">"hello"</span>); <span class="hljs-comment">// 0</span>

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span> &amp;&amp; <span class="hljs-literal">false</span>); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-number">3</span>); <span class="hljs-comment">// false</span>

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-string">""</span>); <span class="hljs-comment">// 0</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">""</span> &amp;&amp; <span class="hljs-number">0</span>); <span class="hljs-comment">// ""</span>
</pre>
        <button class="copy"></button>
      </div>
      <ul class="ul">
        <li>
          У прикладі <code>“hello” &amp;&amp; 0</code> лівий операнд приводиться
          до <code>true</code>, а правий до <code>false</code>, тому результатом
          виразу буде значення правого операнда, який першим був приведений до
          false, тобто <code>0</code>.
        </li>
        <li>
          У приклад <code>0 &amp;&amp; “hello”</code> лівий операнд приводиться
          до <code>false</code>, тому правий операнд не буде обчислюватися.
          Результатом виразу буде значення лівого операнда, який першим був
          приведений до false, тобто <code>0</code>.
        </li>
      </ul>
      <p>
        На практиці логічні операції застосовуються для перевірки множинних
        умов.
      </p>
      <p>
        Варто зазначити, що якщо операндами є вирази, то спочатку вони
        обчислюються, а потім їх результати будуть порівнюватися оператором
        <code>&amp;&amp;</code>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-xl"
          spellcheck="false"
          data-highlighted="yes"
        >const a = <span class="hljs-number">20</span>;
<span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-built_in">log</span>(a &gt; 10 &amp;&amp; a &lt; 30); // <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">true</span> -&gt;</span> <span class="hljs-literal">true</span>

const b = <span class="hljs-number">50</span>;
<span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-built_in">log</span>(b &gt; 10 &amp;&amp; b &lt; 30); // <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">false</span> -&gt;</span> <span class="hljs-literal">false</span>
<span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-built_in">log</span>(b &gt; 80 &amp;&amp; b &lt; 120); // <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-literal">true</span> -&gt;</span> <span class="hljs-literal">false</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>
        У прикладі вище змінна <code>a</code> має одночасно задовольняти дві
        умови: бути 1) більшою за 10, але 2) меншою за 30. Перевірку одночасного
        виконання двох умов ми робимо за допомогою оператора
        <code>&amp;&amp;</code>. Спочатку обчислюємо вирази в операндах.
      </p>
      <img
        src="../js/images/f1afc8a3-7227-44b1-ad39-fd0f52cf9f95Frame 48588.png"
        alt=""
      />
      <p>
        Оператор <code>&amp;&amp;</code> може бути не тільки самостійною умовою,
        а й частиною більш складних умов, наприклад, в умові інструкції
        <code>if</code>
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        >const screenWidth = <span class="hljs-number">700</span>;
const sm = <span class="hljs-number">320</span>;
const md = <span class="hljs-number">768</span>;
const lg = <span class="hljs-number">1200</span>;

<span class="hljs-keyword">if</span>(screenWidth &lt;= sm) {
	<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Mobile screen"</span>);
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(screenWidth &gt; sm &amp;&amp; screenWidth &lt;= md) {
	<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Tablet screen"</span>);
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(screenWidth &gt; md &amp;&amp; screenWidth &lt;= lg) {
	<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Desktop screen"</span>);
} <span class="hljs-keyword">else</span> {
	<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Godzilla screen"</span>);
}
</pre>
        <button class="copy"></button>
      </div>

      <p>1) Перевіряється перша умова:</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-apache"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-attribute">if</span> (<span class="hljs-number">700</span> &lt; <span class="hljs-number">320</span>)
</pre>
        <button class="copy"></button>
      </div>
      <ul class="ul">
        <li>
          Число <code>700</code> не менше <code>320</code>, тому вираз
          <code>false</code>.
        </li>
        <li>Блок <code>if</code> пропускається.</li>
      </ul>
      <p>2) Переходимо до <code>else if</code>:</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-dos"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (screenWidth &gt; sm &amp;&amp; screenWidth ≤ <span class="hljs-built_in">md</span>)
</pre>
        <button class="copy"></button>
      </div>
      <ul class="ul">
        <li>Перевіряється перша частина: <code>700 &gt; 320 // true</code></li>
        <li>Потім друга частина: <code>700 &lt;= 768 // true</code></li>
        <li>
          Вираз має оператор <code>&amp;&amp;</code> (логічне "і"), який
          повертає <code>true</code>,
          <strong>тільки якщо обидві частини </strong
          ><code><strong>true</strong></code
          >.У нашому випадку обидві <code>true</code>, тому
          <code>true &amp;&amp; true</code> дає <code>true</code>.
        </li>
      </ul>
      <p>
        3) Оскільки умова <code>else if</code> спрацювала (<code>true</code>),
        виконується її код:
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Tablet screen"</span>);
</pre>
        <button class="copy"></button>
      </div>
      <p>
        Якщо б ми створювали функцію для перевірки типу екрану, то вона
        виглядала би наступним чином:
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">function</span> <span class="hljs-title function_">getScreenType</span>(<span class="hljs-params">screenWidth</span>) {
  const sm = <span class="hljs-number">320</span>;
  const md = <span class="hljs-number">768</span>;
  const lg = <span class="hljs-number">1200</span>;

  <span class="hljs-keyword">if</span> (screenWidth &lt;= sm) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Mobile screen"</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (screenWidth &gt; sm &amp;&amp; screenWidth &lt;= md) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Tablet screen"</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (screenWidth &gt; md &amp;&amp; screenWidth &lt;= lg) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Desktop screen"</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Godzilla screen"</span>;
  }
}

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(getScreenType(<span class="hljs-number">700</span>));  <span class="hljs-comment">// "Tablet screen"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(getScreenType(<span class="hljs-number">1200</span>)); <span class="hljs-comment">// "Desktop screen"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(getScreenType(<span class="hljs-number">1500</span>)); <span class="hljs-comment">// "Godzilla screen"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(getScreenType(<span class="hljs-number">320</span>));  <span class="hljs-comment">// "Mobile screen"</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>Як працює функція:</p>
      <p>
        <strong>1) Приймає </strong><code><strong>screenWidth</strong></code> –
        ширину екрану як аргумент.
      </p>
      <p><strong>2) Перевіряє умови по черзі:</strong></p>
      <ul class="ul">
        <li>
          <strong>﻿</strong>Якщо <code>screenWidth &lt;= 320</code>, повертає
          <code>"Mobile screen"</code>.
        </li>
        <li>
          Якщо <code>screenWidth</code> більше <code>320</code>, але не більше
          <code>768</code>, повертає <code>"Tablet screen"</code>.
        </li>
        <li>
          Якщо <code>screenWidth</code> більше <code>768</code>, але не більше
          <code>1200</code>, повертає <code>"Desktop screen"</code>.
        </li>
        <li>
          Якщо ширина більша за <code>1200</code>, повертає
          <code>"Godzilla screen"</code>.
        </li>
      </ul>
      <p>
        <strong>3) Використовує </strong><code><strong>return</strong></code
        >, щоб функція могла повертати значення, а не просто виводити в консоль.
      </p>

      <strong class="ql-size-large">Логічне «АБО»</strong>
      <p>
        Оператор "АБО" (<code>||</code>) перетворює всі операнди до логічного
        типу (<code>true</code> або <code>false</code>) і повертає значення
        одного з них.
      </p>
      <p>Дозволяє перевіряти, чи є хоча б один із операндів "істинним”.</p>
      <p>Обчислення оператора відбувається зліва направо.</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-1c"
          spellcheck="false"
          data-highlighted="yes"
        >expression1 <span class="hljs-string">|| expression2</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>
        Якщо <strong>хоча б один із операндів</strong> можна перетворити на
        <code>true</code>, результатом логічного «АБО» буде цей операнд.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-literal">true</span> || <span class="hljs-literal">false</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-literal">false</span> || <span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span>

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> || <span class="hljs-literal">false</span>); <span class="hljs-comment">// 5</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-literal">false</span> || <span class="hljs-number">5</span>); <span class="hljs-comment">// 5</span>

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"hello"</span> || <span class="hljs-number">0</span>); <span class="hljs-comment">// "hello"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">0</span> || <span class="hljs-string">"hello"</span>); <span class="hljs-comment">// "hello"</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>
        Як тільки логічний оператор “АБО” знайшов операнд, який перетворюється
        на <code>true</code>, він зупиняється та повертає його значення. Якщо до
        істини було перетворено <strong>перший операнд</strong>, то другий
        навіть не буде оцінюватися. Це може мати практичне застосування,
        особливо коли другий операнд є виразом, який має високу вартість
        обчислення.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> || <span class="hljs-number">3</span>); <span class="hljs-comment">// 5</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span> || <span class="hljs-number">5</span>); <span class="hljs-comment">// 3</span>

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"mango"</span> || <span class="hljs-string">"poly"</span>); <span class="hljs-comment">// "mango"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"poly"</span> || <span class="hljs-string">"mango"</span>); <span class="hljs-comment">// "poly"</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>
        Якщо <strong>всі операнди</strong> перетворюються на <code>false</code>,
        результатом буде значення <strong>крайнього правого</strong> операнда.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">0</span> || <span class="hljs-literal">false</span>); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-literal">false</span> || <span class="hljs-number">0</span>); <span class="hljs-comment">// 0</span>

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-literal">null</span> || <span class="hljs-string">""</span>); <span class="hljs-comment">// ""</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">""</span> || <span class="hljs-literal">null</span>); <span class="hljs-comment">// null</span>
</pre>
        <button class="copy"></button>
      </div>
      <pre class="ql-blockquote" spellcheck="false">
Оператор "АБО" замикається на вірному операнді і повертає значення операнда, на якому запнувся, або значення крайнього правого операнда. Якщо лівий операнд був перетворений на true, правий операнд не обчислюється.
</pre
      >
      <p>
        На практиці оператор «АБО» також використовується для перевірки
        множинних умов.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-xl"
          spellcheck="false"
          data-highlighted="yes"
        >const a = <span class="hljs-number">5</span>;
<span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-built_in">log</span>(a &lt; 10 || a &gt; 30); // <span class="hljs-literal">true</span> || <span class="hljs-literal">false</span> -&gt;</span> <span class="hljs-literal">true</span>

const b = <span class="hljs-number">50</span>;
<span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-built_in">log</span>(b &lt; 10 || b &gt; 30); // <span class="hljs-literal">false</span> || <span class="hljs-literal">true</span> -&gt;</span> <span class="hljs-literal">true</span>

const c = <span class="hljs-number">20</span>;
<span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-built_in">log</span>(c - 20 || c * 2); // 0 || 40 -&gt;</span> <span class="hljs-number">40</span>
</pre>
        <button class="copy"></button>
      </div>
      <img
        src="../js/images/75216123-2664-4826-9671-f9c1cc220f3e1.jpg"
        alt=""
      />
      <p>Зокрема в умові інструкції <code>if</code>.</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-arduino"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-type">const</span> screenWidth = <span class="hljs-number">700</span>;
<span class="hljs-type">const</span> sm = <span class="hljs-number">320</span>;
<span class="hljs-type">const</span> md = <span class="hljs-number">768</span>;
<span class="hljs-type">const</span> lg = <span class="hljs-number">1200</span>;

<span class="hljs-comment">// У консолі буде пусто, якщо жодна з умов не перетворилась на true</span>
<span class="hljs-keyword">if</span>(screenWidth &lt;= sm || screenWidth &gt; md) {
	console.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Mobile or Desktop screen"</span>);
}
</pre>
        <button class="copy"></button>
      </div>

      <strong class="ql-size-large">Логічне «НІ»</strong>
      <p>
        Усі оператори, які ми розглядали раніше, були&nbsp;бінарними. Бінарні
        оператори містять два операнди: лівий і правий.
      </p>
      <p>
        Логічне «НІ» (<code>!</code>) —
        це&nbsp;<strong>унарний</strong>&nbsp;оператор — він виконує операцію
        над одним операндом праворуч.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax hljs language-diff"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-addition">!expression</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>
        Логічне «НІ» приводить операнд до логічного значення (<code>true</code>
        або <code>false</code>) і потім заперечує (інвертує) його, тобто заміняє
        на протилежне: <code>true</code> —&gt; <code>false</code>, а
        <code>false</code> —&gt; <code>true</code>.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-xl"
          spellcheck="false"
          data-highlighted="yes"
        >console.<span class="hljs-built_in">log</span>(!<span class="hljs-literal">true</span>); <span class="hljs-comment">// false</span>
console.<span class="hljs-built_in">log</span>(!<span class="hljs-literal">false</span>); <span class="hljs-comment">// true</span>
<span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-built_in">log</span>(!3); // !3 -&gt;</span> !<span class="hljs-function"><span class="hljs-title">true</span> -&gt;</span> <span class="hljs-literal">false</span>
<span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-built_in">log</span>(!"Mango"); // !"Mango" -&gt;</span> !<span class="hljs-function"><span class="hljs-title">true</span> -&gt;</span> <span class="hljs-literal">false</span>
<span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-built_in">log</span>(!0); // !0 -&gt;</span> !<span class="hljs-function"><span class="hljs-title">false</span> -&gt;</span> <span class="hljs-literal">true</span>
<span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-built_in">log</span>(!""); // !"" -&gt;</span> !<span class="hljs-function"><span class="hljs-title">false</span> -&gt;</span> <span class="hljs-literal">true</span>
<span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-built_in">log</span>(!null); // !null -&gt;</span> !<span class="hljs-function"><span class="hljs-title">false</span> -&gt;</span> <span class="hljs-literal">true</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>
        На практиці логічне заперечення використовується для перевірки від
        зворотного. Наприклад, можна дозволити написати повідомлення в чаті,
        лише якщо користувач <strong>не</strong> заблокований.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-monkey"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">const</span> isBlocked = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">const</span> canChat = !isBlocked; // !<span class="hljs-literal">false</span> -&gt; <span class="hljs-literal">true</span>

<span class="hljs-keyword">if</span>(canChat) {
	console.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Can type in chat!"</span>)
} <span class="hljs-keyword">else</span> {
	console.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Blocked from typing in chat!"</span>)
}
</pre>
        <button class="copy"></button>
      </div>
      <p>
        У прикладі вище бачимо, що значення змінної <code>isBlocked</code> —
        <code>false</code> . Користувач не заблокований. Результатом
        <code>canChat</code> буде <code>true</code> .
      </p>
      <p>
        Якщо значення змінної <code>isBlocked</code> — <code>true</code>,
        користувач заблокований. У такому разі результат обчислення
        <code>canChat</code> буде <code>false</code>. Отже, умова
        <code>if</code> заборонить користувачеві писати в чаті.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-monkey"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">const</span> isBlocked = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">const</span> canChat = !isBlocked; // !<span class="hljs-literal">true</span> -&gt; <span class="hljs-literal">false</span>

<span class="hljs-keyword">if</span>(canChat) {
	console.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Can type in chat!"</span>)
} <span class="hljs-keyword">else</span> {
	console.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Blocked from typing in chat!"</span>)
}
</pre>
        <button class="copy"></button>
      </div>
      <p>
        Логічне заперечення можна поєднувати з іншими логічними операторами.
        Наприклад, якщо умова можливості писати в чаті залежить від статусу
        онлайн і блокування.
      </p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-autoit"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">const</span> isOnline = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
<span class="hljs-keyword">const</span> isBlocked = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>
<span class="hljs-keyword">const</span> canChat = isOnline &amp;&amp; !isBlocked<span class="hljs-comment">; </span>
// <span class="hljs-literal">true</span> &amp;&amp; !<span class="hljs-literal">false</span> -&gt; <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">true</span> -&gt; <span class="hljs-literal">true</span>

<span class="hljs-keyword">if</span>(canChat) {
	console.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Can type in chat!"</span>)
} <span class="hljs-keyword">else</span> {
	console.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Blocked from typing in chat!"</span>)
}
</pre>
        <button class="copy"></button>
      </div>
      <p>Тепер створимо функцію:</p>
      <div class="ql-syntax-block">
        <pre
          class="ql-syntax ql-block-style-code hljs language-arcade"
          spellcheck="false"
          data-highlighted="yes"
        ><span class="hljs-keyword">function</span> <span class="hljs-title function_">canUserChat</span>(<span class="hljs-params">isOnline, isBlocked</span>) {
  const canChat = isOnline &amp;&amp; !isBlocked;

  <span class="hljs-keyword">if</span> (canChat) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Can type in chat!"</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Blocked from typing in chat!"</span>;
  }
}

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(canUserChat(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>));  <span class="hljs-comment">// "Can type in chat!"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(canUserChat(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>));   <span class="hljs-comment">// "Blocked from typing in chat!"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(canUserChat(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>)); <span class="hljs-comment">// "Blocked from typing in chat!"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(canUserChat(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>));  <span class="hljs-comment">// "Blocked from typing in chat!"</span>
</pre>
        <button class="copy"></button>
      </div>
      <p>Як працює функція:</p>
      <p><strong>1) Приймає два параметри:</strong></p>
      <ul class="ul">
        <li>
          <code
            ><strong><span class="ql-cursor">﻿</span></strong
            >isOnline</code
          >
          – чи користувач онлайн (<code>true</code> або <code>false</code>).
        </li>
        <li>
          <code>isBlocked</code> – чи користувач заблокований (<code>true</code>
          або <code>false</code>).
        </li>
      </ul>
      <p>
        <strong>2) Обчислює змінну</strong>
        <code>const canChat = isOnline &amp;&amp; !isBlocked;</code>
      </p>
      <ul class="ul">
        <li>
          <code>isOnline</code> має бути <code>true</code>, інакше чат
          недоступний.
        </li>
        <li>
          <code>isBlocked</code> має бути <code>false</code>, тому
          використовується <code>!isBlocked</code> (заперечення).
        </li>
      </ul>
      <p>
        <strong>3) Перевіряє значення </strong
        ><code><strong>canChat</strong></code
        ><strong>:</strong>
      </p>
      <ul class="ul">
        <li>
          Якщо <code>true</code>, повертає <code>"Can type in chat!"</code>.
        </li>
        <li>
          Якщо <code>false</code>, повертає
          <code>"Blocked from typing in chat!"</code>.
        </li>
      </ul>
    </section>
    <!--Методи рядків-->
    <section>
      <h2 id="string-methods">Методи рядків</h2>
      <div class="ql-editor">
        <p>
          Уяви автомат із продажу кави. Клієнт може обрати каву з цукром або
          без, з молоком, шоколадом або апельсиновим соком — усе
          це&nbsp;<strong>властивості</strong>&nbsp;кави.
        </p>
        <p>
          Залежно від необхідної властивості, кава буде готуватися різними
          методами — певні рецепти вимагатимуть операції “додати цукор” або
          “додати молоко”, інші — ні. Це різні&nbsp;<strong>методи</strong>.
        </p>
        <p>Так само у програмуванні.</p>
        <p>
          Дані мають набір властивостей і методів, до яких можна звертатися в
          коді. Цей набір називається інтерфейсом. Використання властивостей і
          методів дозволяє нам отримувати інформацію про сутності та виконувати
          операції з ними.
        </p>
        <p><strong class="ql-size-large">Властивості</strong></p>
        <p>У попередніх розділах ми вже познайомилися з властивостями.</p>
        <p>
          Щоб добре розрізняти властивості та методи, варто згадати, що
          властивості — це описові характеристики сутності. У прикладі з кавою —
          це колір, кількість цукру, температура. Наприклад, у програмуванні
          рядок має властивість <code>length</code>, яка повертає кількість
          символів у рядку. Для доступу до властивості використовується
          синтаксис із крапкою:
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-angelscript"
            spellcheck="false"
            data-highlighted="yes"
          >objectName.<span class="hljs-keyword">property</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Щоб отримати довжину рядка, використовується властивість
          <code>length</code>:
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >const message = <span class="hljs-string">"JavaScript is awesome"</span>;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(message.<span class="hljs-built_in">length</span>); <span class="hljs-comment">// 21</span>
</pre>
          <button class="copy"></button>
        </div>
        <p><strong class="ql-size-large">Методи</strong></p>
        <p>
          Методи — це дії, які можна виконати із сутністю, такі як додати цукор
          чи підігріти. У програмуванні дані також заздалегідь мають певні
          методи, які дозволяють виконувати різні операції, наприклад,
          перетворення рядка в різний регістр.
        </p>
        <p>
          Виклик методу дуже схожий на доступ до властивості, але наприкінці
          додаються круглі дужки, як при виклику функції:
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-gml"
            spellcheck="false"
            data-highlighted="yes"
          >objectName.<span class="hljs-built_in">method</span>()
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Ось приклад використання (виклику) методу
          <code>toUpperCase()</code> для перетворення рядка у верхній регістр:
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-pf"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">const</span> message = <span class="hljs-string">"JavaScript is awesome"</span>;
console.<span class="hljs-keyword">log</span>(message.<span class="hljs-keyword">to</span>UpperCase()); // <span class="hljs-string">"JAVASCRIPT IS AWESOME"</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Методи та властивості не можуть існувати самостійно без сутності,
          частиною якої вони є. Не можна викликати метод рядка
          <code>trim()</code> без рядка, не можна отримати значення властивості
          <code>length</code> без рядка або масиву.
        </p>
      </div>

      <div class="ql-editor">
        <p>
          <strong class="ql-size-large">Метод </strong
          ><code class="ql-size-large"><strong>slice()</strong></code>
        </p>
        <p>
          Метод <code>slice()</code> використовується для створення копії
          частини або всього рядка без зміни оригінального рядка. Він дозволяє
          витягувати підрядок з вихідного рядка, вказуючи початковий та кінцевий
          індекси.
        </p>
        <p>Синтаксис методу <code>slice()</code> виглядає так:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-python"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-built_in">str</span>.<span class="hljs-built_in">slice</span>(startIndex, endIndex)
</pre>
          <button class="copy"></button>
        </div>
        <p>де:</p>
        <ul class="ul">
          <li>
            <code>str</code> — вихідний рядок, з якого робитиметься копія.
          </li>
          <li>
            <code>startIndex</code> — індекс, з якого починається копіювання
            елементів рядка.
          </li>
          <li>
            <code>endIndex</code> — індекс, до якого (не включаючи) йде
            копіювання елементів рядка.
          </li>
        </ul>
        <p>
          Метод <code>slice()</code> копіює підрядок із вихідного рядка,
          починаючи з індексу <code>startIndex</code> і до (не включаючи)
          індексу <code>endIndex</code>, і повертає цю копію як новий рядок.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >const fullName = <span class="hljs-string">"Jacob Mercer"</span>;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(fullName.<span class="hljs-built_in">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 'Jaco'</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(fullName.<span class="hljs-built_in">slice</span>(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>)); <span class="hljs-comment">// 'ob Mer'</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(fullName.<span class="hljs-built_in">slice</span>(<span class="hljs-number">0</span>, fullName.<span class="hljs-built_in">length</span>)); <span class="hljs-comment">// 'Jacob Mercer'</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>Параметр <code>endIndex</code> є необов'язковим.</p>
        <p>
          Якщо <code>endIndex</code> не вказаний, витягуються всі елементи до
          кінця рядка.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >const fullName = <span class="hljs-string">"Jacob Mercer"</span>;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(fullName.<span class="hljs-built_in">slice</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 'acob Mercer'</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(fullName.<span class="hljs-built_in">slice</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 'ob Mercer'</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Якщо викликати метод <code>slice()</code> без аргументів, він створює
          точну копію рядка і повертає її.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >const fullName = <span class="hljs-string">"Jacob Mercer"</span>;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(fullName.<span class="hljs-built_in">slice</span>()); <span class="hljs-comment">// 'Jacob Mercer'</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Результат виклику методу <code>slice()</code> можна зберігати в
          змінній для подальшого використання.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >const fullName = <span class="hljs-string">"Jacob Mercer"</span>;
const firstName = fullName.<span class="hljs-built_in">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);
const lastName = fullName.<span class="hljs-built_in">slice</span>(<span class="hljs-number">6</span>);

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(fullName); <span class="hljs-comment">// "Jacob Mercer"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(firstName); <span class="hljs-comment">// "Jacob"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(lastName); <span class="hljs-comment">// "Mercer"</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Метод <code>slice()</code> корисний, коли потрібно отримати певну
          частину рядка або створити копію для подальшого використання, не
          змінюючи вихідний рядок.
        </p>
      </div>

      <div class="ql-editor">
        <p>
          <strong class="ql-size-large">Методи </strong
          ><code class="ql-size-large"><strong>toLowerCase()</strong></code
          ><strong class="ql-size-large"> і </strong
          ><code class="ql-size-large"><strong>toUpperCase()</strong></code>
        </p>
        <p>
          Методи рядків <code>toLowerCase()</code> та
          <code>toUpperCase()</code> використовуються для зміни регістру
          символів у рядку. Обидва методи не змінюють вихідний рядок, а
          повертають новий рядок у відповідному регістрі.
        </p>
        <p>
          Метод <code>toLowerCase()</code> повертає новий рядок, у якому всі
          символи вихідного рядка перетворені в нижній регістр.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-sas"
            spellcheck="false"
            data-highlighted="yes"
          >const <span class="hljs-keyword">message</span> = <span class="hljs-string">"Welcome to Bahamas!"</span>;
console.<span class="hljs-meta">log</span>(<span class="hljs-keyword">message</span>.toLowerCase()); // <span class="hljs-string">"welcome to bahamas!"</span>
console.<span class="hljs-meta">log</span>(<span class="hljs-keyword">message</span>); // <span class="hljs-string">"Welcome to Bahamas!"</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Метод <code>toUpperCase()</code> повертає новий рядок, у якому всі
          символи вихідного рядка перетворені у верхній регістр.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-sas"
            spellcheck="false"
            data-highlighted="yes"
          >const <span class="hljs-keyword">message</span> = <span class="hljs-string">"Welcome to Bahamas!"</span>;
console.<span class="hljs-meta">log</span>(<span class="hljs-keyword">message</span>.toUpperCase()); // <span class="hljs-string">"WELCOME TO BAHAMAS!"</span>
console.<span class="hljs-meta">log</span>(<span class="hljs-keyword">message</span>); // <span class="hljs-string">"Welcome to Bahamas!"</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>Розгляньмо ситуацію:</p>
        <p>
          При пошуку за ключовим словом, користувач вводить рядок
          <code>'saMsUng'</code>, а його треба порівняти з рядком
          <code>'samsung'</code> або <code>'SAMSUNG'</code>.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">'saMsUng'</span> === <span class="hljs-string">'samsung'</span>); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">'saMsUng'</span> === <span class="hljs-string">'SAMSUNG'</span>); <span class="hljs-comment">// false</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Щоб не вимагати абсолютно точного введення, можна зробити
          «нормалізацію» введеного користувачем рядка, тобто перетворити всі
          його символи у верхній або нижній регістр.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >const brandName = <span class="hljs-string">'samsung'</span>;
const userInput = <span class="hljs-string">'saMsUng'</span>;
const lowercaseInput = userInput.toLowerCase();

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(brandName); <span class="hljs-comment">// 'samsung'</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(userInput); <span class="hljs-comment">// 'saMsUng'</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(userInput === brandName); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(lowercaseInput); <span class="hljs-comment">// 'samsung'</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(lowercaseInput === brandName); <span class="hljs-comment">// true</span>
</pre>
          <button class="copy"></button>
        </div>
      </div>

      <div class="ql-editor">
        <p>
          <strong class="ql-size-large">Метод </strong
          ><code class="ql-size-large"><strong>includes()</strong></code>
        </p>
        <p>
          Метод рядків <code>includes()</code> використовується для перевірки
          наявності підрядка у рядку. Він повертає логічне значення
          <code>true</code>, якщо підрядок знайдено, і <code>false</code>, якщо
          підрядок відсутній.
        </p>
        <p>Синтаксис методу <code>includes()</code> виглядає так:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >str.<span class="hljs-built_in">includes</span>(substring)
</pre>
          <button class="copy"></button>
        </div>
        <p>де:</p>
        <ul class="ul">
          <li>
            <code>str</code> — вихідний рядок, у якому ми шукаємо підрядок;
          </li>
          <li>
            <code>substring</code> — підрядок, який ми хочемо знайти у вихідному
            рядку.
          </li>
        </ul>
        <p>Приклад використання методу <code>includes()</code>:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >const username = <span class="hljs-string">'Jacob Mercer'</span>;

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(username.<span class="hljs-built_in">includes</span>(<span class="hljs-string">'Jacob'</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(username.<span class="hljs-built_in">includes</span>(<span class="hljs-string">'John'</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(username.<span class="hljs-built_in">includes</span>(<span class="hljs-string">'Mercer'</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(username.<span class="hljs-built_in">includes</span>(<span class="hljs-string">'Doe'</span>)); <span class="hljs-comment">// false</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Регістр символів у рядку й підрядку <strong>має значення</strong>.
          Літера <code>a</code>, наприклад, не дорівнює літері <code>A</code>.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >const username = <span class="hljs-string">'Jacob Mercer'</span>;

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(username.<span class="hljs-built_in">includes</span>(<span class="hljs-string">'Jacob'</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(username.<span class="hljs-built_in">includes</span>(<span class="hljs-string">'jacob'</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(username.<span class="hljs-built_in">includes</span>(<span class="hljs-string">'Mercer'</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(username.<span class="hljs-built_in">includes</span>(<span class="hljs-string">'mercer'</span>)); <span class="hljs-comment">// false</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Метод <code>includes()</code> корисний, коли нам необхідно виконати
          зазначені дії за умови, коли рядок містить певний підрядок.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-abnf"
            spellcheck="false"
            data-highlighted="yes"
          >const message <span class="hljs-operator">=</span> <span class="hljs-string">"Please buy our stuff!"</span><span class="hljs-comment">;</span>
const hasSpam <span class="hljs-operator">=</span> message.includes(<span class="hljs-string">"buy"</span>)<span class="hljs-comment">;</span>

if (hasSpam) {
  console.log(<span class="hljs-string">"Warning: This message contains forbidden words."</span>)<span class="hljs-comment">;</span>
} else {
  console.log(<span class="hljs-string">"You can safely open this message."</span>)<span class="hljs-comment">;</span>
}
</pre>
          <button class="copy"></button>
        </div>
        <p>
          У цьому прикладі ми перевіряємо, чи містить змінна
          <code>message</code> підрядок <code>"buy"</code>.
        </p>
        <p>
          Якщо це так, виводиться повідомлення з попередженням про вміст
          заборонених слів. В іншому разі відображається повідомлення про те, що
          повідомлення можна відкривати безпечно.
        </p>
      </div>

      <div class="ql-editor">
        <p>
          <strong class="ql-size-large">Методи </strong
          ><code class="ql-size-large"><strong>startsWith()</strong></code
          ><strong class="ql-size-large"> і </strong
          ><code class="ql-size-large"><strong>endsWith()</strong></code>
        </p>
        <p>
          Методи <code>startsWith()</code> і <code>endsWith()</code> призначені
          для перевірки початку й закінчення рядка відповідно. Вони повертають
          булеве значення <code>true</code> або <code>false</code>, залежно від
          того, чи відповідає початок або кінець рядка заданому значенню.
        </p>
        <p>
          <strong>Метод </strong><code><strong>startsWith()</strong></code>
        </p>
        <p>
          Метод <code>startsWith()</code> перевіряє, чи починається рядок із
          зазначеного підрядка.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-axapta"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-built_in">str</span>.startsWith(substr)
</pre>
          <button class="copy"></button>
        </div>
        <p>
          <code>substr</code> — це рядок, з якого має починатися вихідний рядок.
        </p>
        <p>Приклад:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-openscad"
            spellcheck="false"
            data-highlighted="yes"
          >const <span class="hljs-built_in">str</span> = <span class="hljs-string">"Hello, world!"</span>;

console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>.startsWith(<span class="hljs-string">"Hello"</span>)); <span class="hljs-comment">// true</span>
console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>.startsWith(<span class="hljs-string">"hello"</span>)); <span class="hljs-comment">// false (метод чутливий до регістру)</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          <strong>Метод </strong><code><strong>endsWith()</strong></code>
        </p>
        <p>
          Метод <code>endsWith()</code> перевіряє, чи закінчується рядок
          вказаним підрядком.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-axapta"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-built_in">str</span>.endsWith(substr)
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Він також приймає аргументом підрядок, присутність якого потрібно
          перевірити.
        </p>
        <p>Приклад:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-openscad"
            spellcheck="false"
            data-highlighted="yes"
          >const <span class="hljs-built_in">str</span> = <span class="hljs-string">"Hello, world!"</span>;

console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>.endsWith(<span class="hljs-string">"world!"</span>)); <span class="hljs-comment">// true</span>
console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>.endsWith(<span class="hljs-string">"World!"</span>)); <span class="hljs-comment">// false (метод чутливий до регістру)</span>
</pre>
          <button class="copy"></button>
        </div>
        <pre
          class="ql-blockquote"
          spellcheck="false"
        ><strong>Зверни увагу! </strong>
Обидва методи чутливі до регістру символів. Це означає, що під час порівняння підрядка з вихідним рядком регістр символів має збігатися. Якщо в ці методи не передати аргумент, то він повертає false.
</pre>
      </div>

      <div class="ql-editor">
        <p>
          <strong class="ql-size-large">Метод </strong
          ><code class="ql-size-large"><strong>indexOf()</strong></code>
        </p>
        <p>
          Метод <code>indexOf()</code> використовується для пошуку першого
          входження підрядка в рядок. Він повертає:
        </p>
        <ul class="ul">
          <li>
            індекс першого входження (індекс першого символу) підрядка, якщо він
            знайдений або
          </li>
          <li><code>-1</code>, якщо підрядок не виявлено</li>
        </ul>
        <p>Синтаксис:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >str.<span class="hljs-built_in">indexOf</span>(substr)
</pre>
          <button class="copy"></button>
        </div>
        <ul class="ul">
          <li>
            <code>str</code> — вихідний рядок, у якому потрібно виконати пошук;
          </li>
          <li>
            <code>substr</code> — рядок, який потрібно знайти у вихідному рядку.
          </li>
        </ul>
        <p>Приклад:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-abnf"
            spellcheck="false"
            data-highlighted="yes"
          >const message <span class="hljs-operator">=</span> <span class="hljs-string">"Welcome to Bahamas!"</span><span class="hljs-comment">;</span>
const index <span class="hljs-operator">=</span> message.indexOf(<span class="hljs-string">"to"</span>)<span class="hljs-comment">;</span>
console.log(index)<span class="hljs-comment">; // 8</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          У цьому прикладі у нас є рядок <code>message</code>. Ми хочемо знайти
          перше входження підрядка <code>"to"</code>. Метод
          <code>indexOf()</code> виконує пошук у рядку і повертає
          <code>8</code> — індекс першого входження <code>"to"</code>.
        </p>
        <p>
          Якщо підрядок не знайдено, метод <code>indexOf()</code> поверне
          <code>-1</code>:
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-abnf"
            spellcheck="false"
            data-highlighted="yes"
          >const message <span class="hljs-operator">=</span> <span class="hljs-string">"Welcome to Bahamas!"</span><span class="hljs-comment">;</span>
const index <span class="hljs-operator">=</span> message.indexOf(<span class="hljs-string">"hello"</span>)<span class="hljs-comment">;</span>
console.log(index)<span class="hljs-comment">; // -1</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Метод <code>indexOf()</code> корисний, коли тобі потрібно перевірити,
          чи містить рядок певний підрядок і отримати його індекс, якщо його
          знайдено. Цей метод в аргументи може приймати рядок або число. Якщо в
          аргументах буде число, то воно автоматично перетвориться у рядок. А
          якщо нічого не передати, то поверне число -1.
        </p>
      </div>

      <div class="ql-editor">
        <p>
          <strong class="ql-size-large">Метод </strong
          ><code class="ql-size-large"><strong>trim()</strong></code>
        </p>
        <p>
          Метод <code>trim()</code> використовується для видалення початкових і
          кінцевих пробілів із рядка.
        </p>
        <p>
          Це дозволяє "очистити" рядок від зайвих пробілів, наприклад під час
          обробки введення тексту користувачем в елементи форми, видаливши зайві
          пробіли, які могли бути додані випадково.
        </p>
        <p>Синтаксис:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >str.<span class="hljs-built_in">trim</span>()
</pre>
          <button class="copy"></button>
        </div>
        <p>Приклад:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-stata"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">const</span> <span class="hljs-keyword">input</span> = <span class="hljs-string">" JavaScript is awesome!    "</span>;
<span class="hljs-keyword">const</span> trimmedInput = <span class="hljs-keyword">input</span>.<span class="hljs-built_in">trim</span>();
console.<span class="hljs-built_in">log</span>(trimmedInput); <span class="hljs-comment">// "JavaScript is awesome!"</span>
console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">input</span>); <span class="hljs-comment">// " JavaScript is awesome!    "</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          У цьому прикладі метод <code>trim()</code> видаляє пробіли на початку
          та наприкінці рядка, залишаючи тільки текст <code>"</code
          ><code style="color: rgb(0, 0, 0)">JavaScript is awesome!</code
          ><code>"</code>.
        </p>
        <pre
          class="ql-blockquote"
          spellcheck="false"
        ><strong>Зверни увагу! </strong>
Метод trim() не змінює вихідний рядок, а повертає новий рядок без початкових і кінцевих пробілів.
</pre>
      </div>
    </section>
    <!--Цикли-->
    <section>
      <h2 id="loops">Цикли</h2>
      <div class="ql-editor">
        <p>
          Типове завдання у програмуванні — виконання однотипної дії багато
          разів, наприклад вивести клієнтів зі списку один за одним або
          перебрати суми зарплат і для кожної виконати однаковий код. Саме для
          багаторазового повторення однієї частини коду використовуються цикли.
        </p>
        <ul class="ul">
          <li>
            <strong>Цикл</strong> — керуюча конструкція, призначена для
            організації багаторазового виконання набору інструкцій.
          </li>
          <li>
            <strong>Тіло циклу</strong> — послідовність інструкцій, призначена
            для багаторазового виконання.
          </li>
          <li><strong>Ітерація</strong> — одиничне виконання тіла циклу.</li>
          <li>
            <strong>Умова виходу</strong> — вираз, що визначає, чи буде в
            черговий раз виконуватися ітерація, або цикл завершиться.
          </li>
        </ul>
        <!--Цикл while-->
        <p id="while">
          <strong class="ql-size-large">Цикл </strong
          ><code class="ql-size-large"><strong>while</strong></code>
        </p>
        <p>
          Конструкція <code>while</code> створює цикл, який виконує блок коду в
          тілі циклу, поки умова для виходу оцінюється як <code>true</code>.
        </p>
        <img
          src="../js/images/7b79b55e-6f23-4909-afdb-539c1d42839cFrame 48590.jpg"
        />
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax ql-block-style-code hljs language-mel"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">while</span> (<span class="hljs-keyword">condition</span>) {
  statement <span class="hljs-comment">// код, тіло циклу</span>
}
</pre>
          <button class="copy"></button>
        </div>
        <ul class="ul">
          <li>Умова обчислюється перед кожною ітерацією циклу.</li>
          <li>
            Якщо умова оцінюється як <code>true</code>, виконується код у тілі
            циклу (одна ітерація)
          </li>
          <li>
            Якщо умова оцінюється як <code>false</code>, виконання циклу
            переривається і скрипт продовжує виконувати інструкції після циклу
          </li>
        </ul>
        <p>
          <strong>Цикл </strong><code><strong>while</strong></code> — це цикл з
          передумовою, тобто він виконується доки істинна певна умова, зазначена
          перед його початком. Цю умову перевіряють до виконання тіла циклу,
          тому тіло може бути не виконано жодного разу, якщо умова від самого
          початку хибна.
        </p>
        <p>Розгляньмо приклад з лічильником:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax ql-block-style-code hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >let <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;

<span class="hljs-keyword">while</span> (<span class="hljs-built_in">count</span> &lt; <span class="hljs-number">10</span>) {
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`Count: <span class="hljs-subst">${<span class="hljs-built_in">count</span>}</span>`</span>);
  <span class="hljs-built_in">count</span> += <span class="hljs-number">1</span>;
}
</pre>
          <button class="copy"></button>
        </div>
        <p>
          У цьому прикладі у нас є змінна <code><strong>count</strong></code
          >, яка збільшується з кожною ітерацією.
        </p>
        <p>
          Цикл <code><strong>while</strong></code> виконуватиметься доки
          <code><strong>count</strong></code> менше 10. Щойно
          <code><strong>count</strong></code> стане рівним або більшим за 10,
          умова стане хибною, і цикл завершиться.
        </p>
        <p><strong>Задача: Реєстрація у готелі</strong></p>
        <p>
          Змінна <code>clientCounter</code> зберігає кількість зайнятих номерів
          на поточний момент.
        </p>
        <p>
          Змінна <code>maxClients</code> зберігає загальну кількість номерів у
          готелі.
        </p>
        <p>
          Завдяки циклу <code>while</code> місця в готелі будуть заповнюватися
          доти, доки поточна кількість клієнтів не дорівнюватиме максимально
          допустимій.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax ql-block-style-code hljs language-javascript"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">let</span> clientCounter = <span class="hljs-number">18</span>;
<span class="hljs-keyword">const</span> maxClients = <span class="hljs-number">25</span>;

<span class="hljs-keyword">while</span> (clientCounter &lt; maxClients) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clientCounter);
  clientCounter += <span class="hljs-number">1</span>;
}
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Цикл <code>while</code> часто використовується, коли точна кількість
          ітерацій заздалегідь не відома. Отже, цикл має виконуватися до
          виконання певної умови.
        </p>
        <pre class="ql-blockquote" spellcheck="false">
Важливо дбати про те, щоб умова циклу while зрештою стала хибною, щоб уникнути нескінченного виконання.
</pre
        >
        <p>Якби нам потрібно було написати функцію:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax ql-block-style-code hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">function</span> <span class="hljs-title function_">countClients</span>(<span class="hljs-params">clientCounter, maxClients</span>) {
  let counter = clientCounter; <span class="hljs-comment">// створюємо локальну змінну</span>

  <span class="hljs-keyword">while</span> (counter &lt; maxClients) {
    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(counter);
    counter += <span class="hljs-number">1</span>;
  }
}

countClients(<span class="hljs-number">18</span>, <span class="hljs-number">25</span>);
</pre>
          <button class="copy"></button>
        </div>
        <p><strong>Покрокове виконання:</strong></p>
        <p>Виклик <code>countClients(18, 25)</code>:</p>
        <p><strong>1) Перша ітерація:</strong></p>
        <ul>
          <li><code>counter = 18</code></li>
          <li>
            <code>18 &lt; 25</code> → <strong>true</strong>, друкується
            <code>18</code>, <code>counter</code> стає <code>19</code>.
          </li>
        </ul>
        <p><strong>2) Друга ітерація:</strong></p>
        <ul>
          <li><code>counter = 19</code></li>
          <li>
            <code>19 &lt; 25</code> → <strong>true</strong>, друкується
            <code>19</code>, <code>counter</code> стає <code>20</code>.
          </li>
        </ul>
        <p>
          <strong>3) Цикл триває</strong>, поки <code>counter = 25</code>, тоді
          <code>25 &lt; 25</code> → <strong>false</strong>, і він завершується.
        </p>
      </div>
      <!--Цикл do...while-->
      <div class="ql-editor">
        <p id="do...while">
          <strong class="ql-size-large">Цикл </strong
          ><code class="ql-size-large"><strong>do…while</strong></code>
        </p>
        <p>
          У JavaScript існує ще один тип циклу <code>while</code> — це
          <code>do...while</code>.
        </p>
        <p>
          Цикли <code>while</code> і <code>do...while</code> працюють схожим
          чином, але мають одну ключову відмінність. Під час використання циклу
          <code>do...while</code> код у тілі циклу виконується
          <strong>принаймні один раз</strong>, навіть якщо умова не виконується
          з самого початку.
        </p>
        <p>Синтаксис:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-mel"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">do</span> {
   statement <span class="hljs-comment">// код, який буде виконуватися</span>
} <span class="hljs-keyword">while</span> (<span class="hljs-keyword">condition</span>);
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Блок коду всередині <code>do</code> виконується в перший раз незалежно
          від виконання умови.
        </p>
        <p>
          Потім, після кожної ітерації, перевіряється умова. Якщо умова
          оцінюється як <code>true</code>, цикл продовжує виконуватися; якщо —
          як <code>false</code>, цикл завершується.
        </p>
        <p>Розгляньмо приклад:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >let <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;

<span class="hljs-keyword">do</span> {
	<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`Count: <span class="hljs-subst">${<span class="hljs-built_in">count</span>}</span>`</span>);
	<span class="hljs-built_in">count</span> += <span class="hljs-number">1</span>;
} <span class="hljs-keyword">while</span> (<span class="hljs-built_in">count</span> &lt; <span class="hljs-number">5</span>);
</pre>
          <button class="copy"></button>
        </div>
        <p>
          У прикладі код усередині циклу <code>do</code> виконається один раз,
          навіть якщо <code>count</code> більше або дорівнює 5.
        </p>
        <p>
          Після цього умову буде перевірено, і якщо <code>count</code> менше 5,
          цикл продовжить виконуватися.
        </p>
        <p>
          Цикл <code>do...while</code> корисний, коли потрібно, щоб код у блоці
          виконався хоча б один раз, незалежно від умови.
        </p>
      </div>

      <!--Цикл for-->
      <div class="ql-editor">
        <p>
          <strong id="for" class="ql-size-large">Цикл </strong
          ><code class="ql-size-large"><strong>for</strong></code>
        </p>
        <p>
          Цикл <code>for</code> також дозволяє виконувати код, що повторюється,
          багато разів. На відміну від циклів <code>while</code> і
          <code>do…while</code>, цикл <code>for</code> має змінну-лічильник.
          Змінна-лічильник оголошується за допомогою ключового слова
          <code>let</code> (оголошення через <code>const</code> видасть
          помилку). На кожній ітерації після виконання коду з тіла циклу вона
          змінює своє значення від заданого початкового до кінцевого з певним
          кроком.
        </p>
        <p>Синтаксис циклу <code>for</code>:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax ql-block-style-code hljs language-scss"
            spellcheck="false"
            data-highlighted="yes"
          >for (Ініціалізація; Умова; Пост-вираз) {
  <span class="hljs-comment">// Тіло циклу</span>
}
</pre>
          <button class="copy"></button>
        </div>
        <ul>
          <li>
            <strong>Ініціалізація</strong> — виконується
            <strong>один раз перед початком циклу</strong>. Тут оголошується
            змінна-лічильник і вказується її початкове значення.
          </li>
          <li>
            <strong>Умова</strong> — це вираз, який
            <strong>оцінюється перед кожною ітерацією</strong> (повторенням)
            циклу. Якщо умова перетворюється на**<code>true</code>**, то
            виконується тіло циклу. Якщо умова перетворюється на
            <code><strong>false</strong></code
            >, то цикл завершується.
          </li>
          <li>
            <strong>Пост-вираз</strong> — це вираз, який
            <strong>виконується в кінці кожної ітерації циклу</strong>, перед
            перевіркою умови. Використовується для оновлення значення
            змінної-лічильника.
          </li>
          <li>
            <strong>Тіло циклу</strong> — це блок коду, який буде виконуватися
            <strong>на кожній ітерації циклу</strong>, якщо умова перетворюється
            на <code><strong>true</strong></code
            >.
          </li>
        </ul>
        <img
          src="../js/images/3d3b7c4b-570c-443d-9fcf-23ab912ef8c9Frame 48591.jpg"
          alt=""
        />
        <p>Розглянемо приклад:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax ql-block-style-code hljs language-abnf"
            spellcheck="false"
            data-highlighted="yes"
          >for (let i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt;= 20; i += 5) {</span>
  console.log(i)<span class="hljs-comment">;</span>
}
</pre>
          <button class="copy"></button>
        </div>
        <p>
          У наведеному прикладі циклу <code>for</code> змінна
          <code>i</code> ініціалізується значенням <code>0</code>. Цикл
          виконується доти, доки <code>i</code> менша або дорівнює
          <code>20</code>. Після кожної ітерації значення
          <code>i</code> збільшується на <code>5</code>. У результаті в консоль
          будуть виведені числа <code>0</code>, <code>5</code>, <code>10</code>,
          <code>15</code> і <code>20</code>.
        </p>
        <p>
          Також можна зробити зворотний відлік, змінивши умову і зменшуючи
          лічильник на якесь значення після кожної ітерації.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax ql-block-style-code hljs language-abnf"
            spellcheck="false"
            data-highlighted="yes"
          >for (let i <span class="hljs-operator">=</span> <span class="hljs-number">20</span><span class="hljs-comment">; i &gt;= 0; i -= 5) {</span>
  console.log(i)<span class="hljs-comment">;</span>
}
</pre>
          <button class="copy"></button>
        </div>
        <p>
          У наведеному прикладі циклу <code>for</code> змінна
          <code>i</code> ініціалізується значенням <code>20</code>. Цикл
          виконується доти, доки <code>i</code> більше або дорівнює
          <code>0</code>. Після кожної ітерації значення
          <code>i</code> зменшується на <code>5</code>. У результаті в консоль
          будуть виведені числа <code>20</code>, <code>15</code>,
          <code>10</code>, <code>5</code> і <code>0</code>.
        </p>
        <p>
          Напишемо фукнцію яка підсумовує всі числа від <code>0</code> до
          заданого числа і повертає результат:
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax ql-block-style-code hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">function</span> <span class="hljs-title function_">sumUpTo</span>(<span class="hljs-params">number</span>) {
  let <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-built_in">number</span>; i += <span class="hljs-number">1</span>) {
    <span class="hljs-built_in">sum</span> += i;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>;
}

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(sumUpTo(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 15</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(sumUpTo(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 55</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(sumUpTo(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 0</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>Як працює функція:</p>
        <p>
          <strong>1) Приймає один параметр</strong> – <code>number</code>, який
          визначає, до якого числа потрібно підсумовувати.
        </p>
        <p>
          <strong>2) Оголошує змінну </strong
          ><code><strong>sum</strong></code> і встановлює її в <code>0</code> –
          у ній накопичуватиметься сума.
        </p>
        <p>
          <strong>3) Запускає цикл </strong><code><strong>for</strong></code
          >:
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-nginx"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-attribute">for</span> (let i = <span class="hljs-number">0</span>; <span class="hljs-attribute">i</span> &lt;= number; <span class="hljs-attribute">i</span> += <span class="hljs-number">1</span>) {
</pre>
          <button class="copy"></button>
        </div>
        <ul>
          <li><code>i</code> починається з <code>0</code>.</li>
          <li>Працює, поки <code>i &lt;= number</code>.</li>
          <li>
            Після кожної ітерації <code>i</code> збільшується на <code>1</code>.
          </li>
        </ul>
        <p>
          <strong>4) Додає поточне значення </strong
          ><code><strong>i</strong></code
          ><strong> до </strong><code><strong>sum</strong></code
          >:
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-built_in">sum</span> += i;
</pre>
          <button class="copy"></button>
        </div>
        <p>
          <strong
            >5) Після завершення циклу повертає підсумоване значення </strong
          ><code><strong>sum</strong></code
          ><strong> у зовнішній код.</strong>
        </p>
      </div>

      <!--Інкремент і декремент-->
      <div class="ql-editor">
        <p>
          <strong id="increment-decrement" class="ql-size-large"
            >Інкремент і декремент</strong
          >
        </p>
        <p>
          Інкремент (<code>++</code>) і декремент (<code>--</code>) — це
          операції, які відповідно збільшують або зменшують значення числової
          змінної
          <strong>на одиницю</strong> і одразу ж зберігають оновлене значення у
          цій змінній. Існують два види інкременту та декременту: префіксний і
          постфіксний.
        </p>
        <p><strong class="ql-size-large">Інкремент</strong></p>
        <p>
          <strong>Префіксний інкремент</strong> (<code>++value</code>) спочатку
          збільшує значення змінної, а потім використовує нове значення у
          виразі.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-stylus"
            spellcheck="false"
            data-highlighted="yes"
          >let <span class="hljs-attribute">x</span> = <span class="hljs-number">5</span>;
const <span class="hljs-attribute">y</span> = ++x;
console<span class="hljs-selector-class">.log</span>(<span class="hljs-attribute">x</span>); <span class="hljs-comment">// 6</span>
console<span class="hljs-selector-class">.log</span>(<span class="hljs-attribute">y</span>); <span class="hljs-comment">// 6</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          <strong>Постфіксний інкремент</strong> (<code>value++</code>) спочатку
          використовує поточне значення змінної у виразі, а потім виконує
          збільшення значення.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-stylus"
            spellcheck="false"
            data-highlighted="yes"
          >let <span class="hljs-attribute">x</span> = <span class="hljs-number">5</span>;
const <span class="hljs-attribute">y</span> = x++;
console<span class="hljs-selector-class">.log</span>(<span class="hljs-attribute">x</span>); <span class="hljs-comment">// 6</span>
console<span class="hljs-selector-class">.log</span>(<span class="hljs-attribute">y</span>); <span class="hljs-comment">// 5</span>
</pre>
          <button class="copy"></button>
        </div>
        <p><strong class="ql-size-large">Декремент</strong></p>
        <p>
          <strong>Префіксний декремент</strong> (<code>--value</code>) спочатку
          зменшує значення змінної, а потім використовує нове значення у виразі.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-stylus"
            spellcheck="false"
            data-highlighted="yes"
          >let <span class="hljs-attribute">x</span> = <span class="hljs-number">5</span>;
const <span class="hljs-attribute">y</span> = --x;
console<span class="hljs-selector-class">.log</span>(<span class="hljs-attribute">x</span>); <span class="hljs-comment">// 4</span>
console<span class="hljs-selector-class">.log</span>(<span class="hljs-attribute">y</span>); <span class="hljs-comment">// 4</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          <strong>Постфіксний декремент</strong> (<code>value--</code>) спочатку
          використовує поточне значення змінної у виразі, а потім виконує
          зменшення значення.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-stylus"
            spellcheck="false"
            data-highlighted="yes"
          >let <span class="hljs-attribute">x</span> = <span class="hljs-number">5</span>;
const <span class="hljs-attribute">y</span> = x--;
console<span class="hljs-selector-class">.log</span>(<span class="hljs-attribute">x</span>); <span class="hljs-comment">// 4</span>
console<span class="hljs-selector-class">.log</span>(<span class="hljs-attribute">y</span>); <span class="hljs-comment">// 5</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Ці операції корисні, коли тобі потрібно змінювати значення змінних
          одразу на одиницю, що може бути важливо, наприклад, при створенні
          лічильників у циклах, замість комбінованих операторів
          <code>+=</code> і <code>-=</code>.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-abnf"
            spellcheck="false"
            data-highlighted="yes"
          >for (let i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt;= 5; i++) {</span>
  console.log(i)<span class="hljs-comment">;</span>
}
</pre>
          <button class="copy"></button>
        </div>
        <p>
          У прикладі циклу <code>for</code> вище, змінна
          <code>i</code> ініціалізується значенням <code>0</code>, і цикл
          виконується доти, доки <code>i</code> менше або дорівнює
          <code>5</code>. Після кожної ітерації значення
          <code>i</code> збільшується на <code>1</code>. У результаті в консоль
          будуть виведені числа від <code>0</code> до <code>5</code>.
        </p>
      </div>

      <!--Оператор break-->
      <div class="ql-editor">
        <p>
          <strong id="break" class="ql-size-large">Оператор </strong
          ><code class="ql-size-large"><strong>break</strong></code>
        </p>
        <p>
          Оператор <code>break</code> використовується в циклі для переривання
          його виконання. Коли оператор <code>break</code> зустрічається
          всередині циклу, виконання циклу негайно припиняється, і керування
          передається до наступної інструкції після циклу.
        </p>
        <p>
          Оператор <code>break</code> зазвичай використовується разом з умовними
          операторами або операторами порівняння всередині циклу, щоб перевіряти
          певну умову і, якщо вона виконується, переривати виконання циклу.
        </p>
        <p>
          Ось приклад використання оператора <code>break</code> у циклі
          <code>for</code>:
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i+=<span class="hljs-number">1</span>) {
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(i);

  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">5</span>) {
    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">'Met the number 5, interrupt the execution of the cycle'</span>);
    <span class="hljs-keyword">break</span>;
  }
}

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">'Log after cycle'</span>);
</pre>
          <button class="copy"></button>
        </div>
        <p>
          У цьому прикладі цикл <code>for</code> мав би виконуватися, доки
          значення змінної <code>i</code> менше <code>10</code>. Але в тілі
          циклу є умова <code>if (i === 5)</code>, яка перевіряє, чи дорівнює
          значення <code>i</code> числу <code>5</code>. Коли ця умова стає
          істинною, тіло <code>if</code> виконується і застосовується оператор
          <code>break</code>, і виконання циклу припиняється. Таким чином, у
          консоль будуть виведені числа від 0 до 5 (включно), а цикл
          завершиться.
        </p>
      </div>

      <!--Оператор break і функції-->
      <div class="ql-editor">
        <p>
          <strong class="ql-size-large">Оператор </strong
          ><code class="ql-size-large"><strong>break</strong></code
          ><strong class="ql-size-large"> і функції</strong>
        </p>
        <p>
          Коли оператор <code>break</code> зустрічається всередині циклу,
          виконання циклу негайно припиняється, і керування передається на
          наступну інструкцію за циклом, навіть якщо цикл знаходиться всередині
          функції. Тобто оператор <code>break</code> не припиняє виконання
          функції, а тільки перериває цикл.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax ql-block-style-code hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">function</span> <span class="hljs-title function_">findNumber</span>(<span class="hljs-params">max, target</span>) {
	<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Log in the body of the function before the cycle"</span>);

  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">5</span>; i &lt;= <span class="hljs-built_in">max</span>; i += <span class="hljs-number">1</span>) {
    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Current counter value i:"</span>, i);

    <span class="hljs-keyword">if</span> (i === target) {
      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`Found the number $ {target}, interrupt the cycle`</span>);
			<span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Log in body function after cycle"</span>);
}

findNumber(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>);
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Log after exiting function"</span>);
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Для того щоб переривати виконання одразу циклу і функції і повернути
          результат у зовнішній код, є оператор <code>return</code>.
        </p>
        <p>
          У прикладі шукаємо число 6. Щойно виконається умова <code>if</code>,
          робимо повернення, яке перерве виконання циклу і функції.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax ql-block-style-code hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">function</span> <span class="hljs-title function_">findNumber</span>(<span class="hljs-params">max, target</span>) {
	<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Log in the body of the function before the cycle"</span>);

	<span class="hljs-keyword">for</span> (let i = <span class="hljs-number">5</span>; i &lt;= <span class="hljs-built_in">max</span>; i += <span class="hljs-number">1</span>) {
	    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Current counter value i:"</span>, i);
	
	    <span class="hljs-keyword">if</span> (i === target) {
	      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`Found the number $ {target}, we make a return, interrupting the loop and function`</span>);
				<span class="hljs-keyword">return</span> i;
	    }
	  }

  <span class="hljs-comment">// Цей console.log не виконується</span>
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Log in body function after cycle"</span>);
}

const result = findNumber(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>);
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Log after exiting function"</span>);
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`Result of function execution <span class="hljs-subst">${result}</span>`</span>);
</pre>
          <button class="copy"></button>
        </div>
      </div>

      <!--JavaScript Шпаргалка-->
      <section class="js-cheatsheet">
        <h2>JavaScript Шпаргалка</h2>

        <h3>Рядки (String)</h3>
        <ul>
          <li>
            <strong>toUpperCase()</strong> – Перетворює рядок на верхній
            регістр<br />
            <code>'hello'.toUpperCase() // 'HELLO'</code>
          </li>
          <li>
            <strong>toLowerCase()</strong> – Перетворює рядок на нижній
            регістр<br />
            <code>'HELLO'.toLowerCase() // 'hello'</code>
          </li>
          <li>
            <strong>includes()</strong> – Перевіряє, чи містить рядок
            підрядок<br />
            <code>'JavaScript'.includes('Script') // true</code>
          </li>
          <li>
            <strong>indexOf()</strong> – Повертає індекс першого входження або
            -1<br />
            <code>'hello'.indexOf('e') // 1</code>
          </li>
          <li>
            <strong>slice(start, end)</strong> – Повертає підрядок<br />
            <code>'JavaScript'.slice(0, 4) // 'Java'</code>
          </li>
          <li>
            <strong>substring(start, end)</strong> – Повертає підрядок<br />
            <code>'JavaScript'.substring(0, 4) // 'Java'</code>
          </li>
          <li>
            <strong>trim()</strong> – Видаляє пробіли з початку і кінця<br />
            <code>' hello '.trim() // 'hello'</code>
          </li>
          <li>
            <strong>replace(old, new)</strong> – Замінює частину рядка<br />
            <code>'foo bar'.replace('foo', 'baz') // 'baz bar'</code>
          </li>
          <li>
            <strong>split(separator)</strong> – Розбиває рядок у масив<br />
            <code>'a,b,c'.split(',') // ['a', 'b', 'c']</code>
          </li>
          <li>
            <strong>charAt(index)</strong> – Повертає символ за індексом<br />
            <code>'hello'.charAt(1) // 'e'</code>
          </li>
        </ul>

        <h3>Масиви (Array)</h3>
        <ul>
          <li>
            <strong>push()</strong> – Додає елемент в кінець<br />
            <code>[1,2].push(3) // [1,2,3]</code>
          </li>
          <li>
            <strong>pop()</strong> – Видаляє останній елемент<br />
            <code>[1,2,3].pop() // 3</code>
          </li>
          <li>
            <strong>shift()</strong> – Видаляє перший елемент<br />
            <code>[1,2,3].shift() // 1</code>
          </li>
          <li>
            <strong>unshift()</strong> – Додає елемент на початок<br />
            <code>[2,3].unshift(1) // [1,2,3]</code>
          </li>
          <li>
            <strong>slice()</strong> – Повертає частину масиву<br />
            <code>[1,2,3,4].slice(1,3) // [2,3]</code>
          </li>
          <li>
            <strong>splice()</strong> – Додає/видаляє елементи<br />
            <code>[1,2,3].splice(1,1,99) // [1,99,3]</code>
          </li>
          <li>
            <strong>forEach()</strong> – Виконує функцію для кожного елемента<br />
            <code>[1,2,3].forEach(x => console.log(x))</code>
          </li>
          <li>
            <strong>map()</strong> – Створює новий масив, застосовуючи
            функцію<br />
            <code>[1,2,3].map(x => x*2) // [2,4,6]</code>
          </li>
          <li>
            <strong>filter()</strong> – Повертає новий масив, що містить
            елементи, які пройшли перевірку<br />
            <code>[1,2,3].filter(x => x>1) // [2,3]</code>
          </li>
          <li>
            <strong>find()</strong> – Повертає перший елемент, що задовольняє
            умову<br />
            <code>[1,2,3].find(x => x>1) // 2</code>
          </li>
          <li>
            <strong>reduce()</strong> – Агрегує масив в одне значення<br />
            <code>[1,2,3].reduce((acc,x)=>acc+x,0) // 6</code>
          </li>
          <li>
            <strong>includes()</strong> – Перевіряє наявність елемента<br />
            <code>[1,2,3].includes(2) // true</code>
          </li>
          <li>
            <strong>join(separator)</strong> – Перетворює масив в рядок<br />
            <code>[1,2,3].join('-') // '1-2-3'</code>
          </li>
          <li>
            <strong>sort()</strong> – Сортує масив<br />
            <code>[3,1,2].sort() // [1,2,3]</code>
          </li>
        </ul>

        <h3>Числа (Number)</h3>
        <ul>
          <li>
            <strong>toFixed(n)</strong> – Форматує число з n знаками після
            крапки<br />
            <code>3.14159.toFixed(2) // '3.14'</code>
          </li>
          <li>
            <strong>parseInt(str)</strong> – Перетворює рядок на ціле число<br />
            <code>parseInt('10') // 10</code>
          </li>
          <li>
            <strong>parseFloat(str)</strong> – Перетворює рядок на десяткове
            число<br />
            <code>parseFloat('10.5') // 10.5</code>
          </li>
          <li>
            <strong>isNaN(value)</strong> – Перевіряє, чи є значення NaN<br />
            <code>isNaN('abc') // true</code>
          </li>
        </ul>

        <h3>Об'єкти (Object)</h3>
        <ul>
          <li>
            <strong>Object.keys(obj)</strong> – Масив ключів<br />
            <code>Object.keys({a:1, b:2}) // ['a', 'b']</code>
          </li>
          <li>
            <strong>Object.values(obj)</strong> – Масив значень<br />
            <code>Object.values({a:1, b:2}) // [1,2]</code>
          </li>
          <li>
            <strong>Object.entries(obj)</strong> – Масив пар [ключ, значення]<br />
            <code>Object.entries({a:1}) // [['a',1]]</code>
          </li>
          <li>
            <strong>Object.assign(target, source)</strong> – Копіює
            властивості<br />
            <code>Object.assign({}, {a:1}) // {a:1}</code>
          </li>
          <li>
            <strong>hasOwnProperty(key)</strong> – Перевіряє наявність ключа<br />
            <code>{a:1}.hasOwnProperty('a') // true</code>
          </li>
        </ul>

        <h3>Дати (Date)</h3>
        <ul>
          <li>
            <strong>new Date()</strong> – Створює нову дату<br />
            <code>new Date()</code>
          </li>
          <li>
            <strong>getFullYear()</strong> – Отримати рік<br />
            <code>new Date().getFullYear()</code>
          </li>
          <li>
            <strong>getMonth()</strong> – Отримати місяць (0-11)<br />
            <code>new Date().getMonth()</code>
          </li>
          <li>
            <strong>getDate()</strong> – Отримати число місяця<br />
            <code>new Date().getDate()</code>
          </li>
          <li>
            <strong>toLocaleDateString()</strong> – Форматує дату<br />
            <code>new Date().toLocaleDateString()</code>
          </li>
        </ul>

        <h3>Консоль та Взаємодія</h3>
        <ul>
          <li>
            <strong>console.log()</strong> – Виводить в консоль<br />
            <code>console.log('Hello')</code>
          </li>
          <li>
            <strong>alert()</strong> – Вікно повідомлення<br />
            <code>alert('Hi!')</code>
          </li>
          <li>
            <strong>prompt()</strong> – Отримати вхідні дані<br />
            <code>prompt('Your name?')</code>
          </li>
          <li>
            <strong>confirm()</strong> – Діалог підтвердження<br />
            <code>confirm('Are you sure?')</code>
          </li>
        </ul>

        <h3>Інше</h3>
        <ul>
          <li>
            <strong>typeof</strong> – Визначає тип<br />
            <code>typeof 42 // 'number'</code>
          </li>
          <li>
            <strong>Array.isArray()</strong> – Перевіряє, чи масив<br />
            <code>Array.isArray([1,2,3]) // true</code>
          </li>
        </ul>

        <h3>Логічні оператори</h3>
        <ul>
          <li>
            <strong>&&</strong> – Логічне І<br />
            <code>true && false // false</code>
          </li>
          <li>
            <strong>||</strong> – Логічне АБО<br />
            <code>true || false // true</code>
          </li>
          <li>
            <strong>!</strong> – Логічне НЕ<br />
            <code>!true // false</code>
          </li>
        </ul>
      </section>
    </section>

    <!--3. Mодуль 3. Масиви і функції-->
    <!--Масиви-->
    <section>
      <h2 id="arrays">Масиви</h2>
      <div class="ql-editor">
        <p>
          <strong>Масив</strong> — це впорядкована структура даних, яка
          використовується для зберігання колекції елементів. Масиви можуть
          містити елементи різних типів даних, таких як числа, рядки, булеві
          значення тощо.
        </p>
        <p>
          Для створення масиву в JavaScript використовується літерал масиву:
          квадратні дужки <code><strong>[]</strong></code
          >. Усередині дужок перераховуються елементи масиву, розділені комами.
          Ось приклад створення масиву:
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-actionscript"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">const</span> planets = [<span class="hljs-string">'Earth'</span>, <span class="hljs-string">'Mars'</span>, <span class="hljs-string">'Venus'</span>]; <span class="hljs-comment">// масив рядків</span>
<span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// масив чисел</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Хоча в масивах зазвичай зберігаються однотипні дані, це не сувора
          вимога. Масиви також можуть містити елементи різних типів даних.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-actionscript"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">const</span> mixed = [<span class="hljs-string">'apple'</span>, <span class="hljs-number">10</span>, <span class="hljs-literal">true</span>]; <span class="hljs-comment">// масив з елементами різних типів</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Можна провести паралель з овочевим відділом у магазині, де різні види
          овочів зберігаються в окремих ящиках. Наприклад, яблука можуть бути
          поміщені в один ящик, груші — в інший, апельсини — у третій і так
          далі.
        </p>
        <p>
          Подібним чином у програмуванні використовуються масиви для групування
          однотипних елементів разом. Усі елементи всередині масиву зазвичай
          мають один і той самий тип даних або структуру.
        </p>
      </div>

      <!--Доступ до елементів-->
      <div class="ql-editor">
        <p><strong class="ql-size-large">Доступ до елементів</strong></p>
        <p>
          Масив — це впорядкована колекція елементів, де кожен елемент має свій
          порядковий номер, який називається індексом. Індексація елементів
          масиву починається з нуля, тобто перший елемент має індекс 0, другий
          елемент — індекс 1 і так далі.
        </p>
        <img
          src="../js/images/6e495a54-4ea8-402d-88f7-5f74be5eb5bdM03B01S02.jpg"
          alt=""
        />

        <p>
          Щоб отримати доступ до значення елемента масиву, ми використовуємо
          синтаксис квадратних дужок:
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-angelscript"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-built_in">array</span>Name[index]
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Між іменем змінної, яка зберігає масив, і квадратними дужками не
          повинно бути пробілу. Вказуємо індекс елемента всередині квадратних
          дужок.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >const planets = [<span class="hljs-string">'Earth'</span>, <span class="hljs-string">'Mars'</span>, <span class="hljs-string">'Venus'</span>];
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(planets[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 'Earth'</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(planets[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 'Mars'</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(planets[<span class="hljs-number">2</span>]); <span class="hljs-comment">// 'Venus'</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          У цьому прикладі ми створили масив рядків <code>planets</code>, що
          містить назви планет. Потім ми звертаємося до елементів масиву,
          вказуючи відповідний індекс у квадратних дужках.
        </p>
        <p>
          Результат звернення до елемента масиву можна зберегти у змінну і
          використовувати його надалі.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-javascript"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">const</span> planets = [<span class="hljs-string">'Earth'</span>, <span class="hljs-string">'Mars'</span>, <span class="hljs-string">'Venus'</span>];
<span class="hljs-keyword">const</span> firstElement = planets[<span class="hljs-number">0</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstElement); <span class="hljs-comment">// 'Earth'</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Тепер значення першого елемента масиву 'Earth' збережено у змінній
          <code>firstElement</code>, і ми можемо використовувати це значення для
          інших операцій або виразів у коді.
        </p>
        <p>
          Спроба доступу до неіснуючого індексу поверне значення
          <code>undefined</code>.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >const planets = [<span class="hljs-string">'Earth'</span>, <span class="hljs-string">'Mars'</span>, <span class="hljs-string">'Venus'</span>];
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(planets[<span class="hljs-number">3</span>]); <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(planets[<span class="hljs-number">999</span>]); <span class="hljs-comment">// undefined</span>
</pre>
          <button class="copy"></button>
        </div>

        <div class="ql-editor">
          <p>
            <strong class="ql-size-large"
              >Перевизначення значення елемента</strong
            >
          </p>
          <p>
            Елементи масиву можна змінювати, звернувшись до них за індексом і
            присвоївши нове значення. Цей процес називається "перевизначенням"
            значення елемента.
          </p>
          <p>Ось приклад, як перевизначити елементи масиву:</p>
          <div class="ql-syntax-block">
            <pre
              class="ql-syntax hljs language-prolog"
              spellcheck="false"
              data-highlighted="yes"
            >const planets = [<span class="hljs-string">'Earth'</span>, <span class="hljs-string">'Mars'</span>, <span class="hljs-string">'Venus'</span>, <span class="hljs-string">'Uranus'</span>];
planets[<span class="hljs-number">0</span>] = <span class="hljs-string">'Jupiter'</span>;
planets[<span class="hljs-number">2</span>] = <span class="hljs-string">'Neptune'</span>;
console.log(planets); // [<span class="hljs-string">'Jupiter'</span>, <span class="hljs-string">'Mars'</span>, <span class="hljs-string">'Neptune'</span>, <span class="hljs-string">'Uranus'</span>]
</pre>
            <button class="copy"></button>
          </div>
          <p>
            У цьому прикладі ми створили змінну
            <code><strong>planets</strong></code> і помістили в неї масив, що
            містить назви планет. Потім ми звернулися до елементів масиву за
            індексом і надали їм нові значення.
          </p>
          <p>
            Важливо розуміти, що ми не змінили саму змінну
            <code><strong>planets</strong></code
            >, вона, як і раніше, містить масив. Ми просто змінили значення
            всередині цього масиву.
          </p>
          <p>
            Перевизначення елементів масиву дозволяє нам оновлювати дані та
            модифікувати масив під час виконання програми. Це корисно, коли в
            нас є масив даних і ми хочемо змінити або оновити певне значення.
          </p>
        </div>

        <div class="ql-editor">
          <p><strong class="ql-size-large">Довжина масиву</strong></p>
          <p>
            Довжина масиву, тобто кількість його елементів, зберігається у
            властивості <code>length</code>. Це динамічна величина, яка
            автоматично змінюється під час додавання або видалення елементів.
          </p>
          <div class="ql-syntax-block">
            <pre
              class="ql-syntax hljs language-arcade"
              spellcheck="false"
              data-highlighted="yes"
            >const planets = [<span class="hljs-string">'Earth'</span>, <span class="hljs-string">'Mars'</span>, <span class="hljs-string">'Venus'</span>];
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(planets.<span class="hljs-built_in">length</span>); <span class="hljs-comment">// 3</span>
</pre>
            <button class="copy"></button>
          </div>
          <p>
            У цьому прикладі в нас є масив <code>planets</code> із трьома
            елементами. Вираз <code>planets.length</code> поверне значення 3,
            оскільки в масиві міститься три елементи.
          </p>
          <p>
            Знання довжини масиву корисно, коли нам потрібно перевірити, скільки
            елементів у масиві на даний момент.
          </p>
          <div class="ql-syntax-block">
            <pre
              class="ql-syntax hljs language-arcade"
              spellcheck="false"
              data-highlighted="yes"
            >const planets = [<span class="hljs-string">'Earth'</span>, <span class="hljs-string">'Mars'</span>, <span class="hljs-string">'Venus'</span>];

<span class="hljs-keyword">if</span>(planets.<span class="hljs-built_in">length</span> &gt;= <span class="hljs-number">3</span>) {
	<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"3 or more elements"</span>);
} <span class="hljs-keyword">else</span> {
	<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"3 or less elements"</span>);
}
</pre>
            <button class="copy"></button>
          </div>
        </div>

        <div class="ql-editor">
          <p>
            <strong class="ql-size-large">Індекс останнього елемента</strong>
          </p>
          <p>
            Щоб знайти значення останнього елемента масиву, нам потрібно знати
            його індекс. Індекс останнього елемента можна визначити за допомогою
            формули <code>довжина_масиву -1</code>.
          </p>
          <p>
            Оскільки індексація елементів масиву починається з <code>0</code>, а
            довжина масиву зберігає загальну кількість елементів, віднімаючи
            <code>1</code> від довжини масиву, ми отримуємо індекс останнього
            елемента.
          </p>
          <div class="ql-syntax-block">
            <pre
              class="ql-syntax hljs language-arcade"
              spellcheck="false"
              data-highlighted="yes"
            >const planets = [<span class="hljs-string">"Earth"</span>, <span class="hljs-string">"Mars"</span>, <span class="hljs-string">"Venus"</span>];
const lastElementIndex = planets.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(planets[lastElementIndex]); <span class="hljs-comment">// "Venus"</span>
</pre>
            <button class="copy"></button>
          </div>
          <p>
            У цьому прикладі маємо масив <code>planets</code> із трьома
            елементами. Щоб отримати індекс останнього елемента масиву
            оголошується змінна <code>lastElementIndex</code> зі значенням
            <code>planets.length - 1</code>. Маючи індекс останнього елемента в
            масиві, можемо отримати його значення за допомогою
            <code>planets[lastElementIndex]</code>.
          </p>
          <p>
            Такий підхід дозволяє отримати останній елемент масиву незалежно від
            його довжини. Це особливо корисно, коли ми не знаємо заздалегідь,
            скільки елементів міститиметься в масиві.
          </p>
        </div>
        <!--Присвоєння за посиланням і за значенням-->
        <div class="ql-editor">
          <p>
            <strong class="ql-size-large"
              >Присвоєння за посиланням і за значенням</strong
            >
          </p>
          <p>
            Фундаментальною відмінністю складних типів від примітивів є те, як
            вони зберігаються і копіюються.
          </p>
          <p>
            Примітиви: <code>рядки</code>, <code>числа</code>,
            <code>буль</code>, <code>null</code> і <code>undefined</code>, під
            час присвоювання копіюються цілком,
            <strong>за значенням (by value)</strong>.
          </p>
          <p>
            Зі складними типами все не так. У змінній, якій, наприклад,
            присвоєно масив, зберігаються не самі значення елементів масиву, а
            адреса того місця в пам'яті, де цей масив розташовано. Іншими
            словами — посилання (покажчик) на нього.
          </p>
          <p>
            Отже, вони передаються
            <strong>за посиланням (by reference)</strong>.
          </p>
          <p>
            Уявімо змінну у вигляді аркуша паперу. Її значення ми представимо у
            вигляді запису на цьому аркуші.
          </p>
          <img
            src="../js/images/a2fac830-649f-4bf0-b58d-ba515eedc33eFrame 48593.jpg"
            alt=""
          />
          <p>
            Якщо ми захочемо повідомити вміст цього запису користувачам, то
            можемо вчинити так — зробити фізичні копії і вручити їх кожному,
            тобто зробити <strong>множинні</strong> незалежні копії (<strong
              >присвоєння за значенням</strong
            >).
          </p>
          <img
            src="../js/images/ad1baa6f-10ba-47b4-96b0-a86a4c8f806aFrame 48594.jpg"
            alt=""
          />
          <p>
            Або помістити аркуш у зачиненій кімнаті й дати користувачам ключ від
            цієї кімнати, тобто <strong>один екземпляр</strong> із загальним
            доступом (<strong>присвоєння за посиланням</strong>).
          </p>
          <img
            src="../js/images/800048a6-6e43-475b-a7f5-8c4f4b126f92Frame 48595.jpg"
            alt=""
          />
          <p>
            Тепер змінимо дані на аркуші паперу — значення змінної. Очевидно, що
            відвідувачі кімнати завжди бачитимуть зміни, які ми вносимо, бо
            змінюється оригінал і вони мають до нього доступ. Власники паперових
            копій, навпаки, не помітять змін, дивлячись на свої копії.
          </p>
          <img
            src="../js/images/5d111f3f-e6d8-4da8-a155-eb30281ef890Frame 48596.jpg"
            alt=""
          />
          <p>
            Під час присвоєння за значенням змінним виділяється новий осередок
            пам'яті, і в нього копіюються дані. Аналогія з множинними копіями
            паперового аркуша має цілком реальне втілення, окремий аркуш для
            кожної копії.
          </p>
          <p>
            При присвоєнні за посиланням, замість створення нового значення,
            змінній присвоюється посилання (покажчик) на вже існуючий масив,
            тобто на його місце в пам'яті. Таким чином, кілька змінних можуть
            вказувати на один і той самий масив, за аналогією із закритою
            кімнатою, у користувачів є ключ доступу до оригіналу аркуша.
          </p>
          <p>
            Усі примітивні типи присвоюються за значенням, тобто створюється
            копія.
          </p>
          <div class="ql-syntax-block">
            <pre
              class="ql-syntax hljs language-arcade"
              spellcheck="false"
              data-highlighted="yes"
            >let a = <span class="hljs-number">5</span>;

let b = a;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">// 5</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b); <span class="hljs-comment">// 5</span>
<span class="hljs-comment">// Присвоєння за значенням, у пам'яті буде створено ще</span>
<span class="hljs-comment">// одну ячейку, в яку буде скопійовано значення 5</span>

<span class="hljs-comment">// Змінимо значення a</span>
a = <span class="hljs-number">10</span>;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">// 10</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b); <span class="hljs-comment">// 5 Значення b не змінилося, оскільки це окрема копія</span>
</pre>
            <button class="copy"></button>
          </div>
          <div
            class="ql-custom-image"
            contenteditable="false"
            align="center"
            data-blot-name="custom-image"
            data-id="e78b5"
            data-src="https://s3.eu-north-1.amazonaws.com/lms.goit.files/dd9f04b1-2337-4e9c-b382-eab5c4924c85Frame%2048597.jpg"
            data-width="300px"
            data-height="auto"
          >
            <div class="next-1bk4wn6 e11xll1g1">
              <img
                class="ql-custom-image"
                id="e78b5"
                src="https://s3.eu-north-1.amazonaws.com/lms.goit.files/dd9f04b1-2337-4e9c-b382-eab5c4924c85Frame%2048597.jpg"
                groupid="35474143"
                courseid="18936918"
                moduleid="19420991"
                block="[object Object]"
                element="[object Object]"
                userinfo="[object Object]"
              /><button>
                <svg
                  viewBox="0 0 20 20"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <g
                    clip-path="url(#fullscreenExpand_svg__a)"
                    fill="currentcolor"
                  >
                    <path
                      d="M20 19.063V.938A.939.939 0 0 0 19.062 0H.938A.939.939 0 0 0 0 .938v5.625a.312.312 0 1 0 .625 0V.938A.313.313 0 0 1 .938.625h18.125a.313.313 0 0 1 .312.313v18.125a.313.313 0 0 1-.313.312h-5.625a.313.313 0 1 0 0 .625h5.626c.516 0 .937-.42.937-.938Z"
                    ></path>
                    <path
                      d="M.938 8.125A.939.939 0 0 0 0 9.063v10c0 .516.42.937.938.937h10c.516 0 .937-.42.937-.938V8.568l4.375-4.375v4.245a.312.312 0 1 0 .625 0v-5a.312.312 0 0 0-.313-.312h-5a.313.313 0 1 0 0 .625h4.245l-4.375 4.375H.938ZM11.25 19.063a.313.313 0 0 1-.313.312h-10a.312.312 0 0 1-.312-.313v-10a.312.312 0 0 1 .313-.312H11.25v10.313Z"
                    ></path>
                  </g>
                  <defs>
                    <clipPath id="fullscreenExpand_svg__a">
                      <path fill="#fff" d="M0 0h20v20H0z"></path>
                    </clipPath>
                  </defs>
                </svg>
              </button>
            </div>
          </div>
          <p>
            Масиви (складний тип) присвоюються за посиланням, тобто змінна
            просто отримує посилання (покажчик у пам'яті) на вже існуючий масив.
          </p>
          <div class="ql-syntax-block">
            <pre
              class="ql-syntax hljs language-monkey"
              spellcheck="false"
              data-highlighted="yes"
            ><span class="hljs-keyword">const</span> a = [<span class="hljs-string">"Mango"</span>, <span class="hljs-string">"Poly"</span>];
<span class="hljs-keyword">const</span> b = a;
console.<span class="hljs-built_in">log</span>(a); // [<span class="hljs-string">"Mango"</span>, <span class="hljs-string">"Poly"</span>]
console.<span class="hljs-built_in">log</span>(b); // [<span class="hljs-string">"Mango"</span>, <span class="hljs-string">"Poly"</span>]
</pre>
            <button class="copy"></button>
          </div>
          <p>
            Оскільки <code>a</code> це масив, у <code>b</code> записується
            посилання на вже наявний у пам'яті масив. Тепер <code>a</code> і
            <code>b</code> вказують на один і той самий масив.
          </p>
          <div
            class="ql-custom-image"
            contenteditable="false"
            align="center"
            data-blot-name="custom-image"
            data-id="pnnqe"
            data-src="https://s3.eu-north-1.amazonaws.com/lms.goit.files/14060ebd-54f2-46d7-a248-5a33e5f14e3bFrame%2048598.jpg"
            data-width="300px"
            data-height="auto"
          >
            <div class="next-1bk4wn6 e11xll1g1">
              <img
                class="ql-custom-image"
                id="pnnqe"
                src="https://s3.eu-north-1.amazonaws.com/lms.goit.files/14060ebd-54f2-46d7-a248-5a33e5f14e3bFrame%2048598.jpg"
                groupid="35474143"
                courseid="18936918"
                moduleid="19420991"
                block="[object Object]"
                element="[object Object]"
                userinfo="[object Object]"
              /><button>
                <svg
                  viewBox="0 0 20 20"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <g
                    clip-path="url(#fullscreenExpand_svg__a)"
                    fill="currentcolor"
                  >
                    <path
                      d="M20 19.063V.938A.939.939 0 0 0 19.062 0H.938A.939.939 0 0 0 0 .938v5.625a.312.312 0 1 0 .625 0V.938A.313.313 0 0 1 .938.625h18.125a.313.313 0 0 1 .312.313v18.125a.313.313 0 0 1-.313.312h-5.625a.313.313 0 1 0 0 .625h5.626c.516 0 .937-.42.937-.938Z"
                    ></path>
                    <path
                      d="M.938 8.125A.939.939 0 0 0 0 9.063v10c0 .516.42.937.938.937h10c.516 0 .937-.42.937-.938V8.568l4.375-4.375v4.245a.312.312 0 1 0 .625 0v-5a.312.312 0 0 0-.313-.312h-5a.313.313 0 1 0 0 .625h4.245l-4.375 4.375H.938ZM11.25 19.063a.313.313 0 0 1-.313.312h-10a.312.312 0 0 1-.312-.313v-10a.312.312 0 0 1 .313-.312H11.25v10.313Z"
                    ></path>
                  </g>
                  <defs>
                    <clipPath id="fullscreenExpand_svg__a">
                      <path fill="#fff" d="M0 0h20v20H0z"></path>
                    </clipPath>
                  </defs>
                </svg>
              </button>
            </div>
          </div>
          <p>
            Змінимо масив, замінивши елемент з індексом <code>1</code>,
            використовуючи посилання з <code>a</code>.
          </p>
          <div class="ql-syntax-block">
            <pre
              class="ql-syntax hljs language-monkey"
              spellcheck="false"
              data-highlighted="yes"
            ><span class="hljs-keyword">const</span> a = [<span class="hljs-string">"Mango"</span>, <span class="hljs-string">"Poly"</span>];
<span class="hljs-keyword">const</span> b = a;
console.<span class="hljs-built_in">log</span>(a); // [<span class="hljs-string">"Mango"</span>, <span class="hljs-string">"Poly"</span>]
console.<span class="hljs-built_in">log</span>(b); // [<span class="hljs-string">"Mango"</span>, <span class="hljs-string">"Poly"</span>]

a[<span class="hljs-number">1</span>] = <span class="hljs-string">"Jacob"</span>;
console.<span class="hljs-built_in">log</span>(a); // [<span class="hljs-string">"Mango"</span>, <span class="hljs-string">"Jacob"</span>]
console.<span class="hljs-built_in">log</span>(b); // [<span class="hljs-string">"Mango"</span>, <span class="hljs-string">"Jacob"</span>]
</pre>
            <button class="copy"></button>
          </div>
          <p>
            Те, що зберігається в <code><strong>b</strong></code
            >, також змінилося, тому що <code><strong>b</strong></code
            >, як і <code><strong>a</strong></code
            >, просто містить посилання на одне й те саме місце в пам'яті —
            масив.
          </p>
          <p>
            Результат повторюється, якщо використовувати посилання у змінній
            <code>b</code> для зміни масиву.
          </p>
          <div class="ql-syntax-block">
            <pre
              class="ql-syntax hljs language-prolog"
              spellcheck="false"
              data-highlighted="yes"
            >const a = [<span class="hljs-string">"Mango"</span>, <span class="hljs-string">"Poly"</span>];
const b = a;
console.log(a); // [<span class="hljs-string">"Mango"</span>, <span class="hljs-string">"Poly"</span>]
console.log(b); // [<span class="hljs-string">"Mango"</span>, <span class="hljs-string">"Poly"</span>]

a[<span class="hljs-number">1</span>] = <span class="hljs-string">"Jacob"</span>;
console.log(a); // [<span class="hljs-string">"Mango"</span>, <span class="hljs-string">"Jacob"</span>]
console.log(b); // [<span class="hljs-string">"Mango"</span>, <span class="hljs-string">"Jacob"</span>]

b[<span class="hljs-number">0</span>] = <span class="hljs-string">"Ajax"</span>;
console.log(a); // [<span class="hljs-string">"Ajax"</span>, <span class="hljs-string">"Jacob"</span>]
console.log(b); // [<span class="hljs-string">"Ajax"</span>, <span class="hljs-string">"Jacob"</span>]
</pre>
            <button class="copy"></button>
          </div>
          <p>
            Два масиви ніколи не дорівнюють один одному, навіть якщо вони
            порожні або в них однакові елементи.
          </p>
          <div class="ql-syntax-block">
            <pre
              class="ql-syntax hljs language-arcade"
              spellcheck="false"
              data-highlighted="yes"
            >const arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
const arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr1 === arr2); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>([] === []); <span class="hljs-comment">// false</span>
</pre>
            <button class="copy"></button>
          </div>
          <p>
            У прикладах масиви містять однакові значення, але оператор
            <code><strong>===</strong></code> поверне
            <code><strong>false</strong></code
            >, тому що він перевіряє рівність посилань на масиви, а не самих
            елементів усередині масивів. Це можна порівняти з тим, що змінні
            <code>arr1</code> та <code>arr2</code> посилаються на різні кімнати,
            в яких різні папірці, але з однаковим вмістом.
          </p>
        </div>
        <!--Приведення типів: масиви-->
        <div class="ql-editor">
          <p><strong class="ql-size-large">Приведення типів: масиви</strong></p>
          <p>
            Явне і не явне приведення типів масивів здійснюється за необхідності
            виконати операції або порівняння, які вимагають сумісності типів
            даних.
          </p>
          <p><strong class="ql-size-normal">Масив → Рядок</strong></p>
          <p>
            При перетворенні масиву в рядок усі елементи масиву об'єднуються в
            один рядок, розділений комами.
          </p>
          <div class="ql-syntax-block">
            <pre
              class="ql-syntax hljs language-arcade"
              spellcheck="false"
              data-highlighted="yes"
            >const <span class="hljs-built_in">array</span> = [<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">"Poly"</span>];
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(String(<span class="hljs-built_in">array</span>));<span class="hljs-comment">// "1,true,Poly"</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">array</span> + <span class="hljs-string">"5"</span>); <span class="hljs-comment">// "1,true,Poly5"</span>

</pre>
            <button class="copy"></button>
          </div>
          <p><strong class="ql-size-normal">Масив → Число</strong></p>
          <p>
            При перетворенні масиву в число алгоритм складається з двох кроків:
          </p>
          <ul class="ul">
            <li>спочатку масив приводиться до рядка,</li>
            <li>а потім цей рядок приводиться до числового значення.</li>
          </ul>
          <p>
            Наприклад, порожній масив приводиться до порожнього рядка, який
            приводиться до числа <code>0</code>.
          </p>
          <div class="ql-syntax-block">
            <pre
              class="ql-syntax hljs language-arcade"
              spellcheck="false"
              data-highlighted="yes"
            ><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>([])); <span class="hljs-comment">// 0</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>([<span class="hljs-number">1</span>])); <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// NaN</span>
</pre>
            <button class="copy"></button>
          </div>
          <p>
            <strong class="ql-size-normal"
              >Масив → Логічне значення (буль)</strong
            >
          </p>
          <p>
            При перетворенні масиву в логічне значення будь-який масив, навіть
            порожній, перетворюється на <code>true</code>.
          </p>
          <div class="ql-syntax-block">
            <pre
              class="ql-syntax hljs language-arcade"
              spellcheck="false"
              data-highlighted="yes"
            >const emptyArray = [];
const nonEmptyArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(emptyArray)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(nonEmptyArray)); <span class="hljs-comment">// true</span>

<span class="hljs-keyword">if</span>(emptyArray) {
	<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"if is in progress"</span>)
} <span class="hljs-keyword">else</span> {
	<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"else is not performed"</span>)
}

<span class="hljs-keyword">if</span>(nonEmptyArray) {
	<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"if is in progress"</span>)
} <span class="hljs-keyword">else</span> {
	<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">"else is not performed"</span>)
}
</pre>
            <button class="copy"></button>
          </div>
        </div>
      </div>
    </section>

    <!--Методи масиву-->
    <section>
      <h2 id="array-methods">Методи масиву</h2>
      <div class="ql-editor">
        <p>
          У масивів є вбудовані методи, які дозволяють виконувати зручні
          операції для роботи з елементами масиву. Методи масиву дозволяють
          додавати, видаляти, змінювати та виконувати інші операції над
          елементами масиву.
        </p>
        <p id="join()">
          <strong class="ql-size-large">Метод </strong
          ><code class="ql-size-large"><strong>join()</strong></code>
        </p>
        <p>
          Метод масиву <code>join(delimiter)</code> дозволяє об'єднати елементи
          масиву в рядок.
        </p>
        <p>
          У результуючому рядку елементи будуть розділені символом або групою
          символів, зазначених у <code>delimiter</code>.
        </p>
        <p>Приклади використання методу <code>join()</code>:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >const words = [<span class="hljs-string">"JavaScript"</span>, <span class="hljs-string">"is"</span>, <span class="hljs-string">"amazing"</span>];
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(words.join(<span class="hljs-string">""</span>)); <span class="hljs-comment">// 'JavaScriptisamazing'</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(words.join(<span class="hljs-string">" "</span>)); <span class="hljs-comment">// 'JavaScript is amazing'</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(words.join(<span class="hljs-string">"-"</span>)); <span class="hljs-comment">// 'JavaScript-is-amazing'</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Результат роботи методу можна зберегти у змінну для подальшого
          використання.
        </p>
        <p>
          Метод <code>join()</code> корисний за необхідності перетворення масиву
          в рядок з певними роздільниками між елементами. Наприклад, нам
          потрібно написати функцію, яка перетворює рядки зі snake_case (зміїної
          нотації з підкресленнями) в kebab-case (нотацію з тире).
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-csharp"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-function">function <span class="hljs-title">transformString</span>(<span class="hljs-params"><span class="hljs-built_in">string</span></span>)</span> {
	<span class="hljs-keyword">const</span> words = <span class="hljs-built_in">string</span>.split(<span class="hljs-string">"_"</span>);
	<span class="hljs-keyword">return</span> words.<span class="hljs-keyword">join</span>(<span class="hljs-string">"-"</span>);
}

transformString(<span class="hljs-string">"user_age"</span>); <span class="hljs-comment">// "user-age"</span>
transformString(<span class="hljs-string">"price_per_droid"</span>); <span class="hljs-comment">// "price-per-droid"</span>
</pre>
          <button class="copy"></button>
        </div>
      </div>
      <!--Метод split()-->
      <div class="ql-editor">
        <p id="split()">
          <strong class="ql-size-large">Метод </strong
          ><code class="ql-size-large"><strong>split()</strong></code>
        </p>
        <p>
          Метод рядків <code>split(delimiter)</code> виконує зворотну операцію
          порівняно з методом масивів <code>join(delimiter)</code>. Він дозволяє
          перетворити рядок на масив, розбивши його за вказаним роздільником
          <code>delimiter</code>.
        </p>
        <p>
          Якщо роздільник є порожнім рядком (рядком, у якому нема символів), то
          вийде масив окремих символів рядка. Роздільником може бути один або
          кілька символів. Результат роботи методу можна зберегти у змінну для
          подальшого використання.
        </p>
        <p>Приклади використання методу <code>split()</code>:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-monkey"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">const</span> name = <span class="hljs-string">"Mango"</span>;
<span class="hljs-keyword">const</span> letters = name.split(<span class="hljs-string">""</span>);
console.<span class="hljs-built_in">log</span>(letters); // [<span class="hljs-string">"M"</span>, <span class="hljs-string">"a"</span>, <span class="hljs-string">"n"</span>, <span class="hljs-string">"g"</span>, <span class="hljs-string">"o"</span>]

<span class="hljs-keyword">const</span> message = <span class="hljs-string">"JavaScript essentials"</span>;
<span class="hljs-keyword">const</span> words = message.split(<span class="hljs-string">" "</span>);
console.<span class="hljs-built_in">log</span>(words); // [<span class="hljs-string">"JavaScript"</span>, <span class="hljs-string">"essentials"</span>]

<span class="hljs-keyword">const</span> slug = <span class="hljs-string">"amazing-french-recipes"</span>;
<span class="hljs-keyword">const</span> slugParts = slug.split(<span class="hljs-string">"-"</span>);
console.<span class="hljs-built_in">log</span>(slugParts); // [<span class="hljs-string">"amazing"</span>, <span class="hljs-string">"french"</span>, <span class="hljs-string">"recipes"</span>]
</pre>
          <button class="copy"></button>
        </div>
        <ul>
          <li>
            У першому прикладі рядок <code>"Mango"</code> було перетворено на
            масив, де кожна літера стала окремим елементом масиву. Роздільником
            було вказано порожній рядок.
          </li>
          <li>
            У другому прикладі рядок <code>"JavaScript essentials"</code> було
            розділено на два елементи масиву, використовуючи пробіл як
            роздільник.
          </li>
          <li>
            У третьому прикладі рядок <code>"amazing-french-recipes"</code> було
            розділено на три елементи масиву, використовуючи тире як роздільник.
          </li>
        </ul>
      </div>
      <!--Метод slice()-->
      <div class="ql-editor">
        <p id="slice()">
          <strong class="ql-size-large">Метод </strong
          ><code class="ql-size-large"><strong>slice()</strong></code>
        </p>
        <p>
          Метод масиву <code>slice(begin, end)</code> повертає новий масив, що
          містить копію частини вихідного масиву, не змінюючи його. Копія
          створюється від індексу <code>begin</code> до, але не включаючи індекс
          <code>end</code>.
        </p>
        <img
          src="../js/images/b21ed4ba-dc3b-4927-be29-7797c141aee1Frame 48599.jpg"
          alt=""
        />
        <p>Приклади використання методу <code>slice()</code>:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-pgsql"
            spellcheck="false"
            data-highlighted="yes"
          >const planets = ["Earth", "Mars", "Venus", "Jupiter", "Saturn"];
console.log(planets.<span class="hljs-keyword">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)); // [<span class="hljs-string">'Earth'</span>, <span class="hljs-string">'Mars'</span>]
console.log(planets.<span class="hljs-keyword">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>)); // [<span class="hljs-string">'Earth'</span>, <span class="hljs-string">'Mars'</span>, <span class="hljs-string">'Venus'</span>, <span class="hljs-string">'Jupiter'</span>]
console.log(planets.<span class="hljs-keyword">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)); // [<span class="hljs-string">'Mars'</span>, <span class="hljs-string">'Venus'</span>]
</pre>
          <button class="copy"></button>
        </div>
        <ul>
          <li>
            У першому прикладі метод <code>slice(0, 2)</code> створює новий
            масив, що містить елементи з індексами від <code>0</code> до
            <code>2</code> (не включаючи 2) вихідного масиву
            <code>planets</code>. Результатом буде
            <code>['Earth', 'Mars']</code>.
          </li>
          <li>
            У другому прикладі метод <code>slice(0, 4)</code> створює новий
            масив, що містить елементи з індексами від <code>0</code> до
            <code>4</code> (не включаючи 4) вихідного масиву
            <code>planets</code>. Результатом буде
            <code>['Earth', 'Mars', 'Venus', 'Jupiter']</code>.
          </li>
          <li>
            У третьому прикладі метод <code>slice(1, 3)</code> створює новий
            масив, що містить елементи з індексами від <code>1</code> до
            <code>3</code> (не включаючи 3) вихідного масиву
            <code>planets</code>. Результатом буде
            <code>['Mars', 'Venus']</code>.
          </li>
        </ul>
        <p>
          Результат роботи методу <code>slice()</code> можна зберегти у змінну
          для подальшого використання:
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-nim"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">const</span> planets = [<span class="hljs-string">"Earth"</span>, <span class="hljs-string">"Mars"</span>, <span class="hljs-string">"Venus"</span>, <span class="hljs-string">"Jupiter"</span>, <span class="hljs-string">"Saturn"</span>];
<span class="hljs-keyword">const</span> <span class="hljs-built_in">result</span> = planets.slice(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);
console.log(<span class="hljs-built_in">result</span>); // [<span class="hljs-string">"Mars"</span>, <span class="hljs-string">"Venus"</span>]
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Якщо не вказати параметри <code>begin</code> і <code>end</code>, буде
          створено повну копію вихідного масиву:
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-monkey"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">const</span> planets = [<span class="hljs-string">"Earth"</span>, <span class="hljs-string">"Mars"</span>, <span class="hljs-string">"Venus"</span>, <span class="hljs-string">"Jupiter"</span>, <span class="hljs-string">"Saturn"</span>];
console.<span class="hljs-built_in">log</span>(planets.slice()); // [<span class="hljs-string">"Earth"</span>, <span class="hljs-string">"Mars"</span>, <span class="hljs-string">"Venus"</span>, <span class="hljs-string">"Jupiter"</span>, <span class="hljs-string">"Saturn"</span>]
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Якщо не вказати <code>end</code>, копіювання відбуватиметься від
          <code>begin</code> до кінця масиву:
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-pgsql"
            spellcheck="false"
            data-highlighted="yes"
          >const planets = ["Earth", "Mars", "Venus", "Jupiter", "Saturn"];
console.log(planets.<span class="hljs-keyword">slice</span>(<span class="hljs-number">1</span>)); // ["Mars", "Venus", "Jupiter", "Saturn"]
console.log(planets.<span class="hljs-keyword">slice</span>(<span class="hljs-number">2</span>)); // ["Venus", "Jupiter", "Saturn"]
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Якщо значення <code>begin</code> негативне, а <code>end</code> не
          вказано, будуть скопійовані останні <code>begin</code> елементів
          (тобто стільки елементів з кінця, скільки вказано в параметрі
          <code>begin</code>):
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >const planets = [<span class="hljs-string">"Earth"</span>, <span class="hljs-string">"Mars"</span>, <span class="hljs-string">"Venus"</span>, <span class="hljs-string">"Jupiter"</span>, <span class="hljs-string">"Saturn"</span>];
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(planets.<span class="hljs-built_in">slice</span>(<span class="hljs-number">-2</span>)); <span class="hljs-comment">// ["Jupiter", "Saturn"]</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Метод <code>slice()</code> корисний, коли необхідно отримати підмасив
          із вихідного масиву або створити його копію для подальшої роботи з
          ним.
        </p>
      </div>
      <!--Метод concat()-->
      <div class="ql-editor">
        <p id="concat()">
          <strong class="ql-size-large">Метод </strong
          ><code class="ql-size-large"><strong>concat()</strong></code>
        </p>
        <p>
          Метод <code>concat(arr1, arr2, ..., arrN)</code> використовується для
          об'єднання двох або більше масивів.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-nim"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">const</span> firstArray = [<span class="hljs-string">"Mercury"</span>, <span class="hljs-string">"Venus"</span>];
<span class="hljs-keyword">const</span> secondArray = [<span class="hljs-string">"Mars"</span>, <span class="hljs-string">"Jupiter"</span>];
<span class="hljs-keyword">const</span> <span class="hljs-built_in">result</span> = firstArray.concat(secondArray);

console.log(<span class="hljs-built_in">result</span>); // [<span class="hljs-string">"Mercury"</span>, <span class="hljs-string">"Venus"</span>, <span class="hljs-string">"Mars"</span>, <span class="hljs-string">"Jupiter"</span>];
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Зверни увагу, що вихідні масиви <code>firstArray</code> і
          <code>secondArray</code> залишаються незмінними після виклику
          <code>concat()</code>. Метод <code>concat()</code> створює і повертає
          новий масив, що містить усі елементи об'єднаних масивів.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-monkey"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">const</span> firstArray = [<span class="hljs-string">"Mercury"</span>, <span class="hljs-string">"Venus"</span>];
<span class="hljs-keyword">const</span> secondArray = [<span class="hljs-string">"Mars"</span>, <span class="hljs-string">"Jupiter"</span>];
<span class="hljs-keyword">const</span> result = firstArray.concat(secondArray);

console.<span class="hljs-built_in">log</span>(firstArray); // [<span class="hljs-string">"Mercury"</span>, <span class="hljs-string">"Venus"</span>];
console.<span class="hljs-built_in">log</span>(secondArray); // [<span class="hljs-string">"Mars"</span>, <span class="hljs-string">"Jupiter"</span>];
console.<span class="hljs-built_in">log</span>(result); // [<span class="hljs-string">"Mercury"</span>, <span class="hljs-string">"Venus"</span>, <span class="hljs-string">"Mars"</span>, <span class="hljs-string">"Jupiter"</span>];
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Порядок аргументів методу визначає порядок розташування елементів у
          новому масиві.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-autoit"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-keyword">const</span> firstArray = [<span class="hljs-string">"Mercury"</span>, <span class="hljs-string">"Venus"</span>]<span class="hljs-comment">;</span>
<span class="hljs-keyword">const</span> secondArray = [<span class="hljs-string">"Mars"</span>, <span class="hljs-string">"Jupiter"</span>]<span class="hljs-comment">;</span>
<span class="hljs-keyword">const</span> thirdArray = [<span class="hljs-string">"Saturn"</span>, <span class="hljs-string">"Neptune"</span>]<span class="hljs-comment">;</span>

console.<span class="hljs-built_in">log</span>(firstArray.concat(secondArray, thirdArray))<span class="hljs-comment">; </span>
// [<span class="hljs-string">'Mercury'</span>, <span class="hljs-string">'Venus'</span>, <span class="hljs-string">'Mars'</span>, <span class="hljs-string">'Jupiter'</span>, <span class="hljs-string">'Saturn'</span>, <span class="hljs-string">'Neptune'</span>]<span class="hljs-comment">;</span>

console.<span class="hljs-built_in">log</span>(firstArray.concat(thirdArray, secondArray))<span class="hljs-comment">; </span>
// [<span class="hljs-string">'Mercury'</span>, <span class="hljs-string">'Venus'</span>, <span class="hljs-string">'Saturn'</span>, <span class="hljs-string">'Neptune'</span>, <span class="hljs-string">'Mars'</span>, <span class="hljs-string">'Jupiter'</span>, ]<span class="hljs-comment">;</span>
</pre>
          <button class="copy"></button>
        </div>
      </div>

      <!--Метод indexOf()-->
      <div class="ql-editor">
        <p id="indexOf()">
          <strong class="ql-size-large">Метод </strong
          ><code class="ql-size-large"><strong>indexOf()</strong></code>
        </p>
        <p>
          Метод масиву <code>indexOf(elem)</code> використовується для
          визначення індексу першого входження елемента <code>elem</code> у
          масиві. Він повертає індекс елемента, якщо він знайдений, або -1, якщо
          елемент не знайдений. Метод <code>indexOf()</code> виконує сувору
          рівність (<code>===</code>) при порівнянні елементів.
        </p>
        <p>Синтаксис методу <code>indexOf()</code> має такий вигляд:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-built_in">array</span>.<span class="hljs-built_in">indexOf</span>(elem)
</pre>
          <button class="copy"></button>
        </div>
        <ul>
          <li><code>array</code> — масив, у якому здійснюється пошук.</li>
          <li>
            <code>elem</code> — елемент, індекс якого потрібно знайти в масиві.
          </li>
        </ul>
        <p>Приклад використання методу <code>indexOf()</code>:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >const clients = [<span class="hljs-string">"Mango"</span>, <span class="hljs-string">"Ajax"</span>, <span class="hljs-string">"Poly"</span>, <span class="hljs-string">"Kiwi"</span>, <span class="hljs-string">"Poly"</span>];
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(clients.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">"Poly"</span>)); <span class="hljs-comment">// 2</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(clients.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">"Monkong"</span>)); <span class="hljs-comment">// -1</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          У цьому прикладі масив <code>clients</code> містить імена клієнтів.
          Виклик <code>indexOf("Poly")</code> повертає індекс першого входження
          рядка <code>“Poly"</code> у масиві, який дорівнює 2, усі наступні
          входження (індекс 4) уже не будуть аналізуватися. Виклик
          <code>indexOf("Monkong")</code> повертає -1, оскільки елемент
          <code>**"**Monkong**"**</code> не знайдений у масиві.
        </p>
      </div>
      <!--Метод push()-->
      <div class="ql-editor">
        <p id="push()">
          <strong class="ql-size-large">Метод </strong
          ><code class="ql-size-large"><strong>push()</strong></code>
        </p>
        <p>
          Метод масиву <code>push()</code> використовується для додавання одного
          або більше елементів у кінець масиву.
        </p>
        <img src="../js/images/3c2a2dbb-316f-4c0a-b29d-0800005b50ddFrame 48601.jpg" alt=""> 
        <p>Синтаксис методу <code>push()</code> має такий вигляд:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-built_in">array</span>.<span class="hljs-built_in">push</span>(element1, element2, ..., elementN);
</pre>
          <button class="copy"></button>
        </div>
        <p>де:</p>
        <ul class="ul">
          <li>
            <code>array</code> — це вихідний масив, до якого потрібно додати
            елементи;
          </li>
          <li>
            <code>element1, element2, ..., elementN</code> — елементи, які
            необхідно додати в кінець масиву.
          </li>
        </ul>
        <p>Приклад використання методу <code>push()</code>:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-prolog"
            spellcheck="false"
            data-highlighted="yes"
          >const planets = [<span class="hljs-string">"Earth"</span>, <span class="hljs-string">"Mars"</span>, <span class="hljs-string">"Venus"</span>];

planets.push(<span class="hljs-string">"Jupiter"</span>);
console.log(planets); // [<span class="hljs-string">'Earth'</span>, <span class="hljs-string">'Mars'</span>, <span class="hljs-string">'Venus'</span>, <span class="hljs-string">'Jupiter'</span>]

planets.push(<span class="hljs-string">"Saturn"</span>, <span class="hljs-string">"Neptune"</span>);
console.log(planets); // [<span class="hljs-string">'Earth'</span>, <span class="hljs-string">'Mars'</span>, <span class="hljs-string">'Venus'</span>, <span class="hljs-string">'Jupiter'</span>, <span class="hljs-string">"Saturn"</span>, <span class="hljs-string">"Neptune"</span>]
</pre>
          <button class="copy"></button>
        </div>
        <p>
          У прикладі ми створюємо масив <code>planets</code> з вихідними
          елементами "Earth", "Mars" і "Venus". Потім за допомогою методу
          <code>push()</code> послідовно додаємо елементи "Jupiter", "Saturn" і
          "Neptune" у кінець масиву. Після виконання <code>push()</code> масив
          <code>planets</code> міститиме всі додані елементи.
        </p>
        <p>
          За допомогою циклу ми можемо виконувати повторювані операції і
          використовувати метод <code>push</code> для додавання нових елементів
          у масив на кожній ітерації. Це дуже корисно, коли нам потрібно
          створити масив з елементами, які можна динамічно додавати.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arcade"
            spellcheck="false"
            data-highlighted="yes"
          >const tags = [];

<span class="hljs-keyword">for</span>(let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i += <span class="hljs-number">1</span>) {
	tags.<span class="hljs-built_in">push</span>(<span class="hljs-string">`tag-<span class="hljs-subst">${i}</span>`</span>);
}

<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(tags); <span class="hljs-comment">// ["tag-0", "tag-1", "tag-2"]</span>
</pre>
          <button class="copy"></button>
        </div>
        <p>
          Код прикладу створює порожній масив <code>tags</code> і за допомогою
          циклу <code>for</code> додає рядки виду <code>"tag-0"</code>,
          <code>"tag-1"</code>, <code>"tag-2"</code> до масиву. Кожен рядок
          формується за допомогою шаблонного рядка, де значення <code>i</code> в
          циклі використовується для створення унікального тега на кожній
          ітерації. У результаті ми отримуємо масив <code>tags</code>, що
          містить усі додані значення.
        </p>
      </div>
    </section>
  </div>
</section>
